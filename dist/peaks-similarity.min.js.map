{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///peaks-similarity.min.js","webpack:///webpack/bootstrap 6d27dade7d17a263e727","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","getCommonArray","array1","array2","width","newArray","pos2","j","i","length","getIntersection","segment1","segment2","s1_x","s1_y","s2_x","s2_y","p0_x","p0_y","p1_x","p1_y","p2_x","p2_y","p3_x","p3_y","s","t","x","y","normalize","array","sum","min","Number","MAX_VALUE","max","MIN_VALUE","commonExtractAndNormalize","from","to","common","Array","isArray","info","undefined","data","common1","common2","info1","info2","extract1","extract","extract2","COMMON_SECOND","COMMON_FIRST","data1","data2","extractAndNormalize","calculateOverlapFromDiff","diffs","sumPos","Math","abs","COMMON_NO","COMMON_BOTH","options","setOptions","newOptions","toLowerCase","commonFactor","widthBottom","widthTop","setTrapezoid","setFromTo","setPeaks1","anArray","checkArray","extracts","array1Extract","array1ExtractInfo","array2Extract","array2ExtractInfo","setPeaks2","getExtract1","getExtract2","getExtractInfo1","getExtractInfo2","newWidthBottom","newWidthTop","widthSlope","newFrom","newTo","getOverlap","x1","y1","x2","y2","diff","maxValue","getOverlapTrapezoid","factor","small","big","targets","segment","intersection","NaN","calculateDiff","newSecond","push","newFirst","pos1","previous2","trapezoid","overlap","points","xs","ys","getSimilarity","newPeaks1","newPeaks2","result","extractInfo1","extractInfo2","similarity"],"mappings":"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","file":"peaks-similarity.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"peaksSimilarity\"] = factory();\n\telse\n\t\troot[\"peaksSimilarity\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"peaksSimilarity\"] = factory();\n\telse\n\t\troot[\"peaksSimilarity\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tconst COMMON_NO=0;\n\tconst COMMON_FIRST=1;\n\tconst COMMON_SECOND=2;\n\tconst COMMON_BOTH=3; // should be a binary operation !\n\t\n\t\n\tmodule.exports = function Comparator(options) {\n\t    \n\t    var widthTop, widthBottom, from, to;\n\t    var array1Extract, array2Extract, widthSlope, array1ExtractInfo, array2ExtractInfo;\n\t    var common, commonFactor;\n\t\n\t    setOptions(options);\n\t\n\t    var array1=[];\n\t    var array2=[];\n\t \n\t    /*\n\t     2 formats are allowed:\n\t     [[x1,x2,...],[y1,y2,...]] or [[x1,y1],[x2,y2], ...]\n\t    */\n\t\n\t    function setOptions(newOptions) {\n\t        options=newOptions || {};\n\t        if (typeof options.common === 'string') {\n\t            if (options.common.toLowerCase()==='first') {\n\t                common=COMMON_FIRST;\n\t            } else if (options.common.toLowerCase()==='second') {\n\t                common=COMMON_SECOND;\n\t            } else {\n\t                common=COMMON_BOTH;\n\t            }\n\t        } else {\n\t            if (options.common) {\n\t                common=COMMON_BOTH;\n\t            } else {\n\t                common=COMMON_NO;\n\t            }\n\t\n\t        }\n\t        commonFactor=options.commonFactor || commonFactor || 4;\n\t\n\t        if (options.widthBottom==undefined) {\n\t            options.widthBottom=widthBottom || 2;\n\t        }\n\t        if (options.widthTop==undefined) {\n\t            options.widthTop=widthTop || 1;\n\t        }\n\t        setTrapezoid(options.widthBottom, options.widthTop);\n\t        setFromTo(options.from || from, options.to || to);\n\t    }\n\t\n\t    function setPeaks1(anArray) {\n\t        array1=checkArray(anArray);\n\t        if (common) {\n\t            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to, common);\n\t            array1Extract=extracts.data1;\n\t            array1ExtractInfo=extracts.info1;\n\t            array2Extract=extracts.data2;\n\t            array2ExtractInfo=extracts.info2;\n\t        } else {\n\t            var extract=extractAndNormalize(array1, from, to);\n\t            array1Extract=extract.data;\n\t            array1ExtractInfo=extract.info;\n\t        }\n\t    }\n\t    function setPeaks2(anArray) {\n\t        array2=checkArray(anArray);\n\t        if (common) {\n\t            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to, common);\n\t            array1Extract=extracts.data1;\n\t            array1ExtractInfo=extracts.info1;\n\t            array2Extract=extracts.data2;\n\t            array2ExtractInfo=extracts.info2;\n\t        } else {\n\t            var extract = extractAndNormalize(array2, from, to);\n\t            array2Extract = extract.data;\n\t            array2ExtractInfo = extract.info;\n\t        }\n\t    }\n\t\n\t    function getExtract1() {\n\t        return array1Extract;\n\t    }\n\t\n\t    function getExtract2() {\n\t        return array2Extract;\n\t    }\n\t\n\t\n\t    function getExtractInfo1() {\n\t        return array1ExtractInfo;\n\t    }\n\t\n\t    function getExtractInfo2() {\n\t        return array2ExtractInfo;\n\t    }\n\t\n\t    function setTrapezoid(newWidthBottom, newWidthTop) {\n\t        widthTop=newWidthTop;\n\t        widthBottom=newWidthBottom;\n\t        widthSlope=(widthBottom-widthTop)/2;\n\t        if (widthBottom<widthTop) throw \"widthBottom has to be larger than widthTop\";\n\t    }\n\t\n\t    function setFromTo(newFrom, newTo) {\n\t        if (newFrom===from && newTo===to) return\n\t        from=newFrom;\n\t        to=newTo;\n\t        if (common) {\n\t            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to, common, commonFactor);\n\t            array1Extract=extracts.data1;\n\t            array1ExtractInfo=extracts.info1;\n\t            array2Extract=extracts.data2;\n\t            array2ExtractInfo=extracts.info2;\n\t        } else {\n\t            var extract=extractAndNormalize(array1, from, to);\n\t            array1Extract=extract.data;\n\t            array1ExtractInfo=extract.info;\n\t            var extract=extractAndNormalize(array2, from, to);\n\t            array2Extract=extract.data;\n\t            array2ExtractInfo=extract.info;\n\t        }\n\t    }\n\t\n\t\n\t    function getOverlap(x1, y1, x2, y2) {\n\t        if (y1===0 || y2===0) return 0;\n\t\n\t        // TAKE CARE !!! We multiply the diff by 2 !!!\n\t        var diff=Math.abs(x1-x2)*2;\n\t\n\t        if (diff>widthBottom) return 0;\n\t        if (diff<=widthTop) {\n\t            return Math.min(y1,y2);\n\t        }\n\t\n\t        var maxValue=Math.max(y1,y2)*(widthBottom-diff)/(widthBottom-widthTop);\n\t        return Math.min(y1, y2, maxValue);\n\t\n\t        return NaN;\n\t    }\n\t\n\t    // This is the old trapezoid similarity\n\t    function getOverlapTrapezoid(x1, y1, x2, y2) {\n\t        var factor=2/(widthTop+widthBottom); // correction for surface=1\n\t        if (y1===0 || y2===0) return 0;\n\t        if (x1===x2) { // they have the same position\n\t            return Math.min(y1,y2);\n\t        }\n\t\n\t        var diff=Math.abs(x1-x2);\n\t        if (diff>=widthBottom) return 0;\n\t        if (y1===y2) { // do they have the same height ???\n\t            // we need to find the common length\n\t            if (diff<=widthTop) {\n\t                return (((widthTop+widthBottom)/2-diff)*y1)*factor;\n\t            } else if (diff<=widthBottom) {\n\t                return (widthBottom-diff)*y1/2*(diff-widthTop)/(widthBottom-widthTop)*factor;\n\t            }\n\t            return 0;\n\t        } else { // the height are different and not the same position ...\n\t            // we need to consider only one segment to find its intersection\n\t\n\t            var small=Math.min(y1,y2);\n\t            var big=Math.max(y1,y2);\n\t\n\t            var targets=[\n\t                [[0,0],[widthSlope,small]],\n\t                [[widthSlope,small],[widthSlope+widthTop,small]],\n\t                [[widthTop+widthSlope,small],[widthBottom,0]]\n\t            ];\n\t            if ((x1>x2 && y1>y2) || (x1<x2 && y1<y2)) {\n\t                var segment=[[diff,0],[diff+widthSlope,big]];\n\t            } else {\n\t                var segment=[[diff+widthSlope,big],[diff,0]];\n\t            }\n\t\n\t\n\t\n\t            for (var i=0; i<3; i++) {\n\t                var intersection=getIntersection(targets[i],segment);\n\t                if (intersection) {\n\t                    switch (i) {\n\t                        case 0:\n\t                            return small-((diff*intersection.y/2))*factor;\n\t                        case 1: // to simplify ...\n\t                            //     console.log(\"           \",widthSlope,small,big,intersection.x)\n\t                            return ((widthSlope*small/(2*big))*small+\n\t                                (widthTop+widthSlope-intersection.x)*small+\n\t                                widthSlope*small/2)*factor;\n\t                        case 2:\n\t                            return ((widthBottom-diff)*intersection.y/2)*factor;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return NaN;\n\t    }\n\t\n\t\n\t\n\t    // this method calculates the total diff. The sum of positive value will yield to overlap\n\t    function calculateDiff() {\n\t        // we need to take 2 pointers\n\t        // and travel progressively between them ...\n\t        var newSecond=[];\n\t        for (var i=0; i<array2Extract.length; i++) {\n\t            newSecond.push([array2Extract[i][0],array2Extract[i][1]]);\n\t        }\n\t        var newFirst=[];\n\t        for (var i=0; i<array1Extract.length; i++) {\n\t            newFirst.push([array1Extract[i][0],array1Extract[i][1]]);\n\t        }\n\t\n\t        var pos1=0;\n\t        var pos2=0;\n\t        var previous2=0;\n\t        while (pos1<newFirst.length) {\n\t            var diff=newFirst[pos1][0]-array2Extract[pos2][0];\n\t            if (Math.abs(diff)<widthBottom) { // there is some overlap\n\t                if (options.trapezoid) {\n\t                    var overlap=getOverlapTrapezoid(newFirst[pos1][0], newFirst[pos1][1], newSecond[pos2][0], newSecond[pos2][1], widthTop, widthBottom);\n\t\n\t                } else {\n\t                    var overlap=getOverlap(newFirst[pos1][0], newFirst[pos1][1], newSecond[pos2][0], newSecond[pos2][1], widthTop, widthBottom);\n\t                }\n\t                newFirst[pos1][1]-=overlap;\n\t                newSecond[pos2][1]-=overlap;\n\t                if (pos2<(array2Extract.length-1)) {\n\t                    pos2++;\n\t                } else {\n\t                    pos1++;\n\t                    pos2=previous2;\n\t                }\n\t            } else {\n\t                if (diff>0 && pos2<(array2Extract.length-1)) {\n\t                    pos2++;\n\t                    previous2=pos2;\n\t                } else {\n\t                    pos1++;\n\t                    pos2=previous2;\n\t                }\n\t            }\n\t        }\n\t        return newSecond;\n\t    }\n\t\n\t\n\t    /*\n\t        This code requires the use of an array like  [[x1,y1],[x2,y2], ...]\n\t        If it is not the right format, we will just convert it\n\t        Otherwise we return the correct format\n\t     */\n\t    function checkArray(points) {\n\t        // if it is already a 2D array of points, we just return them\n\t        if (Array.isArray(points) && Array.isArray(points[0]) && points[0].length===2) return points;\n\t        var xs=points[0];\n\t        var ys=points[1];\n\t        var array=[];\n\t        for (var i=0; i<xs.length; i++) {\n\t            array.push([xs[i],ys[i]]);\n\t        }\n\t        return array;\n\t    }\n\t\n\t    function getSimilarity(newPeaks1, newPeaks2) {\n\t        if (newPeaks1) setPeaks1(newPeaks1);\n\t        if (newPeaks2) setPeaks2(newPeaks2);\n\t        var result={};\n\t        result.diff=calculateDiff();\n\t        result.extract1=getExtract1();\n\t        result.extract2=getExtract2();\n\t        result.extractInfo1=getExtractInfo1();\n\t        result.extractInfo2=getExtractInfo2();\n\t        result.similarity=calculateOverlapFromDiff(result.diff);\n\t        return result;\n\t    }\n\t\n\t    this.setPeaks1 = setPeaks1;\n\t    this.setPeaks2 = setPeaks2;\n\t    this.getExtract1 = getExtract1;\n\t    this.getExtract2 = getExtract2;\n\t    this.getExtractInfo1 = getExtractInfo1;\n\t    this.getExtractInfo2 = getExtractInfo2;\n\t    this.setFromTo = setFromTo;\n\t    this.setOptions = setOptions;\n\t    this.setTrapezoid = setTrapezoid;\n\t    this.getSimilarity = getSimilarity;\n\t    this.getCommonArray = getCommonArray;\n\t};\n\t\n\t\n\t// returns an new array based on array1 where there is a peak of array2 at a distance under width/2\n\tfunction getCommonArray(array1, array2, width) {\n\t    var newArray=[];\n\t    var pos2=0;\n\t    width/=2;\n\t    var j=0;\n\t\n\t    for (var i=0; i<array1.length; i++) {\n\t        while (pos2<array2.length && (array1[i][0]>(array2[pos2][0]+width))) {\n\t            pos2++;\n\t        }\n\t        if ((pos2<array2.length) && (array1[i][0]>array2[pos2][0]-width)) {\n\t            newArray[j++]=array1[i];\n\t        }\n\t    }\n\t    return newArray;\n\t}\n\t\n\t\n\t// Adapted from: http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/1968345#1968345\n\tfunction getIntersection(segment1, segment2) {\n\t    var p0_x=segment1[0][0];\n\t    var p0_y=segment1[0][1];\n\t    var p1_x=segment1[1][0];\n\t    var p1_y=segment1[1][1];\n\t    var p2_x=segment2[0][0];\n\t    var p2_y=segment2[0][1];\n\t    var p3_x=segment2[1][0];\n\t    var p3_y=segment2[1][1];\n\t\n\t    var s1_x, s1_y, s2_x, s2_y;\n\t    s1_x = p1_x - p0_x;\n\t    s1_y = p1_y - p0_y;\n\t    s2_x = p3_x - p2_x;\n\t    s2_y = p3_y - p2_y;\n\t    var s, t;\n\t    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);\n\t    t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);\n\t    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n\t        return {\n\t            x:p0_x + (t * s1_x),\n\t            y:p0_y + (t * s1_y)\n\t        }\n\t    }\n\t    return null; // No collision\n\t}\n\t\n\tfunction normalize(array) {\n\t    var sum=0;\n\t    var min=Number.MAX_VALUE;\n\t    var max=Number.MIN_VALUE;\n\t    for (var i=0; i<array.length; i++) {\n\t        sum+=array[i][1];\n\t        if (array[i][1]<min) min=array[i][1];\n\t        if (array[i][1]>max) max=array[i][1];\n\t    }\n\t    if (sum!=0) {\n\t        for (var i=0; i<array.length; i++) {\n\t            array[i][1]/=sum;\n\t        }\n\t    }\n\t    return {\n\t        sum: sum,\n\t        min: min,\n\t        max: max\n\t    };\n\t}\n\t\n\t// this method will systemtatically take care of both array\n\tfunction commonExtractAndNormalize(array1, array2, width, from, to, common) {\n\t    if (! (Array.isArray(array1)) || ! (Array.isArray(array2))) return {\n\t        info: undefined,\n\t        data: undefined\n\t    };\n\t    var extract1=extract(array1, from, to);\n\t    var extract2=extract(array2, from, to);\n\t    var common1, common2, info1, info2;\n\t    if (common & COMMON_SECOND) {\n\t        common1=getCommonArray(extract1, extract2, width);\n\t        info1=normalize(common1);\n\t    } else {\n\t        common1=extract1;\n\t        info1=normalize(common1);\n\t    }\n\t    if (common & COMMON_FIRST) {\n\t        common2=getCommonArray(extract2, extract1, width);\n\t        info2=normalize(common2);\n\t    } else {\n\t        common2=extract2;\n\t        info2=normalize(common2);\n\t    }\n\t\n\t    return {\n\t        info1: info1,\n\t        info2: info2,\n\t        data1: common1,\n\t        data2: common2\n\t    }\n\t}\n\t\n\tfunction extract(array, from, to) {\n\t    var newArray=[];\n\t    var j=0;\n\t    for (var i=0; i<array.length; i++) {\n\t        if ( (! from || array[i][0]>=from)  && (! to || array[i][0]<=to)) {\n\t            newArray[j++] = [array[i][0], array[i][1]];\n\t        }\n\t    }\n\t    return newArray;\n\t}\n\t\n\tfunction extractAndNormalize(array, from, to) {\n\t    if (! (Array.isArray(array))) return {\n\t        info: undefined,\n\t        data: undefined\n\t    };\n\t    var newArray=extract(array, from, to);\n\t    var info=normalize(newArray);\n\t    return {\n\t        info: info,\n\t        data: newArray\n\t    };\n\t}\n\t\n\tfunction calculateOverlapFromDiff(diffs) {\n\t    var sumPos=0;\n\t    for (var i=0; i<diffs.length; i++) {\n\t        sumPos+=Math.abs(diffs[i][1]);\n\t    }\n\t    return 1-sumPos;\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** peaks-similarity.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6d27dade7d17a263e727\n **/","'use strict';\n\nconst COMMON_NO=0;\nconst COMMON_FIRST=1;\nconst COMMON_SECOND=2;\nconst COMMON_BOTH=3; // should be a binary operation !\n\n\nmodule.exports = function Comparator(options) {\n    \n    var widthTop, widthBottom, from, to;\n    var array1Extract, array2Extract, widthSlope, array1ExtractInfo, array2ExtractInfo;\n    var common, commonFactor;\n\n    setOptions(options);\n\n    var array1=[];\n    var array2=[];\n \n    /*\n     2 formats are allowed:\n     [[x1,x2,...],[y1,y2,...]] or [[x1,y1],[x2,y2], ...]\n    */\n\n    function setOptions(newOptions) {\n        options=newOptions || {};\n        if (typeof options.common === 'string') {\n            if (options.common.toLowerCase()==='first') {\n                common=COMMON_FIRST;\n            } else if (options.common.toLowerCase()==='second') {\n                common=COMMON_SECOND;\n            } else {\n                common=COMMON_BOTH;\n            }\n        } else {\n            if (options.common) {\n                common=COMMON_BOTH;\n            } else {\n                common=COMMON_NO;\n            }\n\n        }\n        commonFactor=options.commonFactor || commonFactor || 4;\n\n        if (options.widthBottom==undefined) {\n            options.widthBottom=widthBottom || 2;\n        }\n        if (options.widthTop==undefined) {\n            options.widthTop=widthTop || 1;\n        }\n        setTrapezoid(options.widthBottom, options.widthTop);\n        setFromTo(options.from || from, options.to || to);\n    }\n\n    function setPeaks1(anArray) {\n        array1=checkArray(anArray);\n        if (common) {\n            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to, common);\n            array1Extract=extracts.data1;\n            array1ExtractInfo=extracts.info1;\n            array2Extract=extracts.data2;\n            array2ExtractInfo=extracts.info2;\n        } else {\n            var extract=extractAndNormalize(array1, from, to);\n            array1Extract=extract.data;\n            array1ExtractInfo=extract.info;\n        }\n    }\n    function setPeaks2(anArray) {\n        array2=checkArray(anArray);\n        if (common) {\n            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to, common);\n            array1Extract=extracts.data1;\n            array1ExtractInfo=extracts.info1;\n            array2Extract=extracts.data2;\n            array2ExtractInfo=extracts.info2;\n        } else {\n            var extract = extractAndNormalize(array2, from, to);\n            array2Extract = extract.data;\n            array2ExtractInfo = extract.info;\n        }\n    }\n\n    function getExtract1() {\n        return array1Extract;\n    }\n\n    function getExtract2() {\n        return array2Extract;\n    }\n\n\n    function getExtractInfo1() {\n        return array1ExtractInfo;\n    }\n\n    function getExtractInfo2() {\n        return array2ExtractInfo;\n    }\n\n    function setTrapezoid(newWidthBottom, newWidthTop) {\n        widthTop=newWidthTop;\n        widthBottom=newWidthBottom;\n        widthSlope=(widthBottom-widthTop)/2;\n        if (widthBottom<widthTop) throw \"widthBottom has to be larger than widthTop\";\n    }\n\n    function setFromTo(newFrom, newTo) {\n        if (newFrom===from && newTo===to) return\n        from=newFrom;\n        to=newTo;\n        if (common) {\n            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to, common, commonFactor);\n            array1Extract=extracts.data1;\n            array1ExtractInfo=extracts.info1;\n            array2Extract=extracts.data2;\n            array2ExtractInfo=extracts.info2;\n        } else {\n            var extract=extractAndNormalize(array1, from, to);\n            array1Extract=extract.data;\n            array1ExtractInfo=extract.info;\n            var extract=extractAndNormalize(array2, from, to);\n            array2Extract=extract.data;\n            array2ExtractInfo=extract.info;\n        }\n    }\n\n\n    function getOverlap(x1, y1, x2, y2) {\n        if (y1===0 || y2===0) return 0;\n\n        // TAKE CARE !!! We multiply the diff by 2 !!!\n        var diff=Math.abs(x1-x2)*2;\n\n        if (diff>widthBottom) return 0;\n        if (diff<=widthTop) {\n            return Math.min(y1,y2);\n        }\n\n        var maxValue=Math.max(y1,y2)*(widthBottom-diff)/(widthBottom-widthTop);\n        return Math.min(y1, y2, maxValue);\n\n        return NaN;\n    }\n\n    // This is the old trapezoid similarity\n    function getOverlapTrapezoid(x1, y1, x2, y2) {\n        var factor=2/(widthTop+widthBottom); // correction for surface=1\n        if (y1===0 || y2===0) return 0;\n        if (x1===x2) { // they have the same position\n            return Math.min(y1,y2);\n        }\n\n        var diff=Math.abs(x1-x2);\n        if (diff>=widthBottom) return 0;\n        if (y1===y2) { // do they have the same height ???\n            // we need to find the common length\n            if (diff<=widthTop) {\n                return (((widthTop+widthBottom)/2-diff)*y1)*factor;\n            } else if (diff<=widthBottom) {\n                return (widthBottom-diff)*y1/2*(diff-widthTop)/(widthBottom-widthTop)*factor;\n            }\n            return 0;\n        } else { // the height are different and not the same position ...\n            // we need to consider only one segment to find its intersection\n\n            var small=Math.min(y1,y2);\n            var big=Math.max(y1,y2);\n\n            var targets=[\n                [[0,0],[widthSlope,small]],\n                [[widthSlope,small],[widthSlope+widthTop,small]],\n                [[widthTop+widthSlope,small],[widthBottom,0]]\n            ];\n            if ((x1>x2 && y1>y2) || (x1<x2 && y1<y2)) {\n                var segment=[[diff,0],[diff+widthSlope,big]];\n            } else {\n                var segment=[[diff+widthSlope,big],[diff,0]];\n            }\n\n\n\n            for (var i=0; i<3; i++) {\n                var intersection=getIntersection(targets[i],segment);\n                if (intersection) {\n                    switch (i) {\n                        case 0:\n                            return small-((diff*intersection.y/2))*factor;\n                        case 1: // to simplify ...\n                            //     console.log(\"           \",widthSlope,small,big,intersection.x)\n                            return ((widthSlope*small/(2*big))*small+\n                                (widthTop+widthSlope-intersection.x)*small+\n                                widthSlope*small/2)*factor;\n                        case 2:\n                            return ((widthBottom-diff)*intersection.y/2)*factor;\n                    }\n                }\n            }\n        }\n        return NaN;\n    }\n\n\n\n    // this method calculates the total diff. The sum of positive value will yield to overlap\n    function calculateDiff() {\n        // we need to take 2 pointers\n        // and travel progressively between them ...\n        var newSecond=[];\n        for (var i=0; i<array2Extract.length; i++) {\n            newSecond.push([array2Extract[i][0],array2Extract[i][1]]);\n        }\n        var newFirst=[];\n        for (var i=0; i<array1Extract.length; i++) {\n            newFirst.push([array1Extract[i][0],array1Extract[i][1]]);\n        }\n\n        var pos1=0;\n        var pos2=0;\n        var previous2=0;\n        while (pos1<newFirst.length) {\n            var diff=newFirst[pos1][0]-array2Extract[pos2][0];\n            if (Math.abs(diff)<widthBottom) { // there is some overlap\n                if (options.trapezoid) {\n                    var overlap=getOverlapTrapezoid(newFirst[pos1][0], newFirst[pos1][1], newSecond[pos2][0], newSecond[pos2][1], widthTop, widthBottom);\n\n                } else {\n                    var overlap=getOverlap(newFirst[pos1][0], newFirst[pos1][1], newSecond[pos2][0], newSecond[pos2][1], widthTop, widthBottom);\n                }\n                newFirst[pos1][1]-=overlap;\n                newSecond[pos2][1]-=overlap;\n                if (pos2<(array2Extract.length-1)) {\n                    pos2++;\n                } else {\n                    pos1++;\n                    pos2=previous2;\n                }\n            } else {\n                if (diff>0 && pos2<(array2Extract.length-1)) {\n                    pos2++;\n                    previous2=pos2;\n                } else {\n                    pos1++;\n                    pos2=previous2;\n                }\n            }\n        }\n        return newSecond;\n    }\n\n\n    /*\n        This code requires the use of an array like  [[x1,y1],[x2,y2], ...]\n        If it is not the right format, we will just convert it\n        Otherwise we return the correct format\n     */\n    function checkArray(points) {\n        // if it is already a 2D array of points, we just return them\n        if (Array.isArray(points) && Array.isArray(points[0]) && points[0].length===2) return points;\n        var xs=points[0];\n        var ys=points[1];\n        var array=[];\n        for (var i=0; i<xs.length; i++) {\n            array.push([xs[i],ys[i]]);\n        }\n        return array;\n    }\n\n    function getSimilarity(newPeaks1, newPeaks2) {\n        if (newPeaks1) setPeaks1(newPeaks1);\n        if (newPeaks2) setPeaks2(newPeaks2);\n        var result={};\n        result.diff=calculateDiff();\n        result.extract1=getExtract1();\n        result.extract2=getExtract2();\n        result.extractInfo1=getExtractInfo1();\n        result.extractInfo2=getExtractInfo2();\n        result.similarity=calculateOverlapFromDiff(result.diff);\n        return result;\n    }\n\n    this.setPeaks1 = setPeaks1;\n    this.setPeaks2 = setPeaks2;\n    this.getExtract1 = getExtract1;\n    this.getExtract2 = getExtract2;\n    this.getExtractInfo1 = getExtractInfo1;\n    this.getExtractInfo2 = getExtractInfo2;\n    this.setFromTo = setFromTo;\n    this.setOptions = setOptions;\n    this.setTrapezoid = setTrapezoid;\n    this.getSimilarity = getSimilarity;\n    this.getCommonArray = getCommonArray;\n};\n\n\n// returns an new array based on array1 where there is a peak of array2 at a distance under width/2\nfunction getCommonArray(array1, array2, width) {\n    var newArray=[];\n    var pos2=0;\n    width/=2;\n    var j=0;\n\n    for (var i=0; i<array1.length; i++) {\n        while (pos2<array2.length && (array1[i][0]>(array2[pos2][0]+width))) {\n            pos2++;\n        }\n        if ((pos2<array2.length) && (array1[i][0]>array2[pos2][0]-width)) {\n            newArray[j++]=array1[i];\n        }\n    }\n    return newArray;\n}\n\n\n// Adapted from: http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/1968345#1968345\nfunction getIntersection(segment1, segment2) {\n    var p0_x=segment1[0][0];\n    var p0_y=segment1[0][1];\n    var p1_x=segment1[1][0];\n    var p1_y=segment1[1][1];\n    var p2_x=segment2[0][0];\n    var p2_y=segment2[0][1];\n    var p3_x=segment2[1][0];\n    var p3_y=segment2[1][1];\n\n    var s1_x, s1_y, s2_x, s2_y;\n    s1_x = p1_x - p0_x;\n    s1_y = p1_y - p0_y;\n    s2_x = p3_x - p2_x;\n    s2_y = p3_y - p2_y;\n    var s, t;\n    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);\n    t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n        return {\n            x:p0_x + (t * s1_x),\n            y:p0_y + (t * s1_y)\n        }\n    }\n    return null; // No collision\n}\n\nfunction normalize(array) {\n    var sum=0;\n    var min=Number.MAX_VALUE;\n    var max=Number.MIN_VALUE;\n    for (var i=0; i<array.length; i++) {\n        sum+=array[i][1];\n        if (array[i][1]<min) min=array[i][1];\n        if (array[i][1]>max) max=array[i][1];\n    }\n    if (sum!=0) {\n        for (var i=0; i<array.length; i++) {\n            array[i][1]/=sum;\n        }\n    }\n    return {\n        sum: sum,\n        min: min,\n        max: max\n    };\n}\n\n// this method will systemtatically take care of both array\nfunction commonExtractAndNormalize(array1, array2, width, from, to, common) {\n    if (! (Array.isArray(array1)) || ! (Array.isArray(array2))) return {\n        info: undefined,\n        data: undefined\n    };\n    var extract1=extract(array1, from, to);\n    var extract2=extract(array2, from, to);\n    var common1, common2, info1, info2;\n    if (common & COMMON_SECOND) {\n        common1=getCommonArray(extract1, extract2, width);\n        info1=normalize(common1);\n    } else {\n        common1=extract1;\n        info1=normalize(common1);\n    }\n    if (common & COMMON_FIRST) {\n        common2=getCommonArray(extract2, extract1, width);\n        info2=normalize(common2);\n    } else {\n        common2=extract2;\n        info2=normalize(common2);\n    }\n\n    return {\n        info1: info1,\n        info2: info2,\n        data1: common1,\n        data2: common2\n    }\n}\n\nfunction extract(array, from, to) {\n    var newArray=[];\n    var j=0;\n    for (var i=0; i<array.length; i++) {\n        if ( (! from || array[i][0]>=from)  && (! to || array[i][0]<=to)) {\n            newArray[j++] = [array[i][0], array[i][1]];\n        }\n    }\n    return newArray;\n}\n\nfunction extractAndNormalize(array, from, to) {\n    if (! (Array.isArray(array))) return {\n        info: undefined,\n        data: undefined\n    };\n    var newArray=extract(array, from, to);\n    var info=normalize(newArray);\n    return {\n        info: info,\n        data: newArray\n    };\n}\n\nfunction calculateOverlapFromDiff(diffs) {\n    var sumPos=0;\n    for (var i=0; i<diffs.length; i++) {\n        sumPos+=Math.abs(diffs[i][1]);\n    }\n    return 1-sumPos;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}