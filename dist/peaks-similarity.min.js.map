{"version":3,"sources":["peaks-similarity.min.js"],"names":["e","exports","module","define","amd","f","window","global","self","peaksSimilarity","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"getCommonArray","array1","array2","width","newArray","pos2","j","getIntersection","segment1","segment2","s1_x","s1_y","s2_x","s2_y","p0_x","p0_y","p1_x","p1_y","p2_x","p2_y","p3_x","p3_y","x","y","normalize","array","sum","min","Number","MAX_VALUE","max","MIN_VALUE","commonExtractAndNormalize","from","to","Array","isArray","info","undefined","data","extract1","extract","extract2","common1","common2","info1","info2","data1","data2","extractAndNormalize","calculateOverlapFromDiff","diffs","sumPos","Math","abs","options","setOptions","newOptions","common","widthBottom","widthTop","setTrapezoid","setFromTo","setPeaks1","anArray","checkArray","extracts","array1Extract","array1ExtractInfo","array2Extract","array2ExtractInfo","setPeaks2","getExtract1","getExtract2","getExtractInfo1","getExtractInfo2","newWidthBottom","newWidthTop","console","log","widthSlope","newFrom","newTo","getOverlap","x1","y1","x2","y2","diff","maxValue","getOverlapTrapezoid","factor","small","big","targets","segment","intersection","NaN","calculateDiff","newSecond","push","newFirst","pos1","previous2","trapezoid","overlap","points","xs","ys","getSimilarity","newPeaks1","newPeaks2","result","extractInfo1","extractInfo2","similarity","this"],"mappings":"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","file":"peaks-similarity.min.js","sourcesContent":["/**\n * peaks-similarity - Peaks similarity - calculate the similarity between 2 ordered array of peaks\n * @version v1.3.1\n * @link https://github.com/cheminfo-js/peaks-similarity\n * @license MIT\n */\n!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.peaksSimilarity=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function Comparator(options) {\n    \n    var widthTop, widthBottom, from, to;\n    var array1Extract, array2Extract, widthSlope, array1ExtractInfo, array2ExtractInfo;\n    var common;\n\n    setOptions(options);\n\n    var array1=[];\n    var array2=[];\n \n    /*\n     2 formats are allowed:\n     [[x1,x2,...],[y1,y2,...]] or [[x1,y1],[x2,y2], ...]\n    */\n\n    function setOptions(newOptions) {\n        options=newOptions || {};\n        common=options.common || common || false;\n        if (options.widthBottom==undefined) {\n            options.widthBottom==widthBottom || 2;\n        }\n        if (options.widthTop==undefined) {\n            options.widthTop==widthTop || 1;\n        }\n        setTrapezoid(options.widthBottom, options.widthTop);\n        setFromTo(options.from || from, options.to || to);\n    }\n\n    function setPeaks1(anArray) {\n        array1=checkArray(anArray);\n        if (common) {\n            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to);\n            array1Extract=extracts.data1;\n            array1ExtractInfo=extracts.info1;\n            array2Extract=extracts.data2;\n            array2ExtractInfo=extracts.info2;\n        } else {\n            var extract=extractAndNormalize(array1, from, to);\n            array1Extract=extract.data;\n            array1ExtractInfo=extract.info;\n        }\n    }\n    function setPeaks2(anArray) {\n        array2=checkArray(anArray);\n        if (common) {\n            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to);\n            array1Extract=extracts.data1;\n            array1ExtractInfo=extracts.info1;\n            array2Extract=extracts.data2;\n            array2ExtractInfo=extracts.info2;\n        } else {\n            var extract = extractAndNormalize(array2, from, to);\n            array2Extract = extract.data;\n            array2ExtractInfo = extract.info;\n        }\n    }\n\n    function getExtract1() {\n        return array1Extract;\n    }\n\n    function getExtract2() {\n        return array2Extract;\n    }\n\n\n    function getExtractInfo1() {\n        return array1ExtractInfo;\n    }\n\n    function getExtractInfo2() {\n        return array2ExtractInfo;\n    }\n\n    function setTrapezoid(newWidthBottom, newWidthTop) {\n        console.log(newWidthBottom, newWidthTop)\n\n        widthTop=newWidthTop;\n        widthBottom=newWidthBottom;\n        widthSlope=(widthBottom-widthTop)/2;\n        if (widthBottom<widthTop) throw \"widthBottom has to be larger than widthTop\";\n    }\n\n    function setFromTo(newFrom, newTo) {\n        if (newFrom===from && newTo===to) return\n        from=newFrom;\n        to=newTo;\n        if (common) {\n            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to);\n            array1Extract=extracts.data1;\n            array1ExtractInfo=extracts.info1;\n            array2Extract=extracts.data2;\n            array2ExtractInfo=extracts.info2;\n        } else {\n            var extract=extractAndNormalize(array1, from, to);\n            array1Extract=extract.data;\n            array1ExtractInfo=extract.info;\n            var extract=extractAndNormalize(array2, from, to);\n            array2Extract=extract.data;\n            array2ExtractInfo=extract.info;\n        }\n    }\n\n\n    function getOverlap(x1, y1, x2, y2) {\n        if (y1===0 || y2===0) return 0;\n\n        // TAKE CARE !!! We multiply the diff by 2 !!!\n        var diff=Math.abs(x1-x2)*2;\n\n        if (diff>widthBottom) return 0;\n        if (diff<=widthTop) {\n            return Math.min(y1,y2);\n        }\n\n        var maxValue=Math.max(y1,y2)*(widthBottom-diff)/(widthBottom-widthTop);\n        return Math.min(y1, y2, maxValue);\n\n        return NaN;\n    }\n\n    // This is the old trapezoid similarity\n    function getOverlapTrapezoid(x1, y1, x2, y2) {\n        var factor=2/(widthTop+widthBottom); // correction for surface=1\n        if (y1===0 || y2===0) return 0;\n        if (x1===x2) { // they have the same position\n            return Math.min(y1,y2);\n        }\n\n        var diff=Math.abs(x1-x2);\n        if (diff>=widthBottom) return 0;\n        if (y1===y2) { // do they have the same height ???\n            // we need to find the common length\n            if (diff<=widthTop) {\n                return (((widthTop+widthBottom)/2-diff)*y1)*factor;\n            } else if (diff<=widthBottom) {\n                return (widthBottom-diff)*y1/2*(diff-widthTop)/(widthBottom-widthTop)*factor;\n            }\n            return 0;\n        } else { // the height are different and not the same position ...\n            // we need to consider only one segment to find its intersection\n\n            var small=Math.min(y1,y2);\n            var big=Math.max(y1,y2);\n\n            var targets=[\n                [[0,0],[widthSlope,small]],\n                [[widthSlope,small],[widthSlope+widthTop,small]],\n                [[widthTop+widthSlope,small],[widthBottom,0]]\n            ];\n            if ((x1>x2 && y1>y2) || (x1<x2 && y1<y2)) {\n                var segment=[[diff,0],[diff+widthSlope,big]];\n            } else {\n                var segment=[[diff+widthSlope,big],[diff,0]];\n            }\n\n\n\n            for (var i=0; i<3; i++) {\n                var intersection=getIntersection(targets[i],segment);\n                if (intersection) {\n                    switch (i) {\n                        case 0:\n                            return small-((diff*intersection.y/2))*factor;\n                        case 1: // to simplify ...\n                            //     console.log(\"           \",widthSlope,small,big,intersection.x)\n                            return ((widthSlope*small/(2*big))*small+\n                                (widthTop+widthSlope-intersection.x)*small+\n                                widthSlope*small/2)*factor;\n                        case 2:\n                            return ((widthBottom-diff)*intersection.y/2)*factor;\n                    }\n                }\n            }\n        }\n        return NaN;\n    }\n\n\n\n    // this method calculates the total diff. The sum of positive value will yield to overlap\n    function calculateDiff() {\n        // we need to take 2 pointers\n        // and travel progressively between them ...\n        var newSecond=[];\n        for (var i=0; i<array2Extract.length; i++) {\n            newSecond.push([array2Extract[i][0],array2Extract[i][1]]);\n        }\n        var newFirst=[];\n        for (var i=0; i<array1Extract.length; i++) {\n            newFirst.push([array1Extract[i][0],array1Extract[i][1]]);\n        }\n\n        var pos1=0;\n        var pos2=0;\n        var previous2=0;\n        while (pos1<newFirst.length) {\n            var diff=newFirst[pos1][0]-array2Extract[pos2][0];\n            if (Math.abs(diff)<widthBottom) { // there is some overlap\n                if (options.trapezoid) {\n                    var overlap=getOverlapTrapezoid(newFirst[pos1][0], newFirst[pos1][1], newSecond[pos2][0], newSecond[pos2][1], widthTop, widthBottom);\n\n                } else {\n                    var overlap=getOverlap(newFirst[pos1][0], newFirst[pos1][1], newSecond[pos2][0], newSecond[pos2][1], widthTop, widthBottom);\n                }\n                newFirst[pos1][1]-=overlap;\n                newSecond[pos2][1]-=overlap;\n                if (pos2<(array2Extract.length-1)) {\n                    pos2++;\n                } else {\n                    pos1++;\n                    pos2=previous2;\n                }\n            } else {\n                if (diff>0 && pos2<(array2Extract.length-1)) {\n                    pos2++;\n                    previous2=pos2;\n                } else {\n                    pos1++;\n                    pos2=previous2;\n                }\n            }\n        }\n        return newSecond;\n    }\n\n\n    /*\n        This code requires the use of an array like  [[x1,y1],[x2,y2], ...]\n        If it is not the right format, we will just convert it\n        Otherwise we return the correct format\n     */\n    function checkArray(points) {\n        // if it is already a 2D array of points, we just return them\n        if (Array.isArray(points) && Array.isArray(points[0]) && points[0].length===2) return points;\n        var xs=points[0];\n        var ys=points[1];\n        var array=[];\n        for (var i=0; i<xs.length; i++) {\n            array.push([xs[i],ys[i]]);\n        }\n        return array;\n    }\n\n    function getSimilarity(newPeaks1, newPeaks2) {\n        if (newPeaks1) setPeaks1(newPeaks1);\n        if (newPeaks2) setPeaks2(newPeaks2);\n        var result={};\n        result.diff=calculateDiff();\n        result.extract1=getExtract1();\n        result.extract2=getExtract2();\n        result.extractInfo1=getExtractInfo1();\n        result.extractInfo2=getExtractInfo2();\n        result.similarity=calculateOverlapFromDiff(result.diff);\n        return result;\n    }\n\n    this.setPeaks1 = setPeaks1;\n    this.setPeaks2 = setPeaks2;\n    this.getExtract1 = getExtract1;\n    this.getExtract2 = getExtract2;\n    this.getExtractInfo1 = getExtractInfo1;\n    this.getExtractInfo2 = getExtractInfo2;\n    this.setFromTo = setFromTo;\n    this.setOptions = setOptions;\n    this.setTrapezoid = setTrapezoid;\n    this.getSimilarity = getSimilarity;\n    this.getCommonArray = getCommonArray;\n};\n\n\n// returns an new array based on array1 where there is a peak of array2 at a distance under width/2\nfunction getCommonArray(array1, array2, width) {\n    var newArray=[];\n    var pos2=0;\n    width/=2;\n    var j=0;\n\n    for (var i=0; i<array1.length; i++) {\n        while (pos2<array2.length && (array1[i][0]>(array2[pos2][0]+width))) {\n            pos2++;\n        }\n        if ((pos2<array2.length) && (array1[i][0]>array2[pos2][0]-width)) {\n            newArray[j++]=array1[i];\n        }\n    }\n    return newArray;\n}\n\n\n// Adapted from: http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/1968345#1968345\nfunction getIntersection(segment1, segment2) {\n    var p0_x=segment1[0][0];\n    var p0_y=segment1[0][1];\n    var p1_x=segment1[1][0];\n    var p1_y=segment1[1][1];\n    var p2_x=segment2[0][0];\n    var p2_y=segment2[0][1];\n    var p3_x=segment2[1][0];\n    var p3_y=segment2[1][1];\n\n    var s1_x, s1_y, s2_x, s2_y;\n    s1_x = p1_x - p0_x;\n    s1_y = p1_y - p0_y;\n    s2_x = p3_x - p2_x;\n    s2_y = p3_y - p2_y;\n    var s, t;\n    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);\n    t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n        return {\n            x:p0_x + (t * s1_x),\n            y:p0_y + (t * s1_y)\n        }\n    }\n    return null; // No collision\n}\n\nfunction normalize(array) {\n    var sum=0;\n    var min=Number.MAX_VALUE;\n    var max=Number.MIN_VALUE;\n    for (var i=0; i<array.length; i++) {\n        sum+=array[i][1];\n        if (array[i][1]<min) min=array[i][1];\n        if (array[i][1]>max) max=array[i][1];\n    }\n    if (sum!=0) {\n        for (var i=0; i<array.length; i++) {\n            array[i][1]/=sum;\n        }\n    }\n    return {\n        sum: sum,\n        min: min,\n        max: max\n    };\n}\n\n// this method will systemtatically take care of both array\nfunction commonExtractAndNormalize(array1, array2, width, from, to) {\n    if (! (Array.isArray(array1)) || ! (Array.isArray(array2))) return {\n        info: undefined,\n        data: undefined\n    };\n    var extract1=extract(array1, from, to);\n    var extract2=extract(array2, from, to);\n    var common1=getCommonArray(extract1, extract2, width);\n    var common2=getCommonArray(extract2, extract1, width);\n    var info1=normalize(common1);\n    var info2=normalize(common2);\n    return {\n        info1: info1,\n        info2: info2,\n        data1: common1,\n        data2: common2\n    }\n}\n\nfunction extract(array, from, to) {\n    var newArray=[];\n    var j=0;\n    for (var i=0; i<array.length; i++) {\n        if ( (! from || array[i][0]>=from)  && (! to || array[i][0]<=to)) {\n            newArray[j++] = [array[i][0], array[i][1]];\n        }\n    }\n    return newArray;\n}\n\nfunction extractAndNormalize(array, from, to) {\n    if (! (Array.isArray(array))) return {\n        info: undefined,\n        data: undefined\n    };\n    var newArray=extract(array, from, to);\n    var info=normalize(newArray);\n    return {\n        info: info,\n        data: newArray\n    };\n}\n\nfunction calculateOverlapFromDiff(diffs) {\n    var sumPos=0;\n    for (var i=0; i<diffs.length; i++) {\n        sumPos+=Math.abs(diffs[i][1]);\n    }\n    return 1-sumPos;\n}\n},{}]},{},[1])(1)\n});"],"sourceRoot":"/source/"}