{"version":3,"sources":["webpack:///peaks-similarity/webpack/universalModuleDefinition","webpack:///peaks-similarity/peaks-similarity.min.js","webpack:///peaks-similarity/webpack/bootstrap d1318b775e42c5b0c876","webpack:///peaks-similarity/./src/index.js","webpack:///peaks-similarity/./~/ml-stat/index.js","webpack:///peaks-similarity/./~/ml-stat/array.js","webpack:///peaks-similarity/./~/ml-stat/matrix.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","getCommonArray","array1","array2","width","newArray","pos2","j","array1Length","length","array2Length","i","getIntersection","segment1","segment2","s1_x","s1_y","s2_x","s2_y","p0_x","p0_y","p1_x","p1_y","p2_x","p2_y","p3_x","p3_y","s","t","x","y","normalize","array","min","Stat","max","sum","commonExtractAndNormalize","from","to","common","Array","isArray","info","undefined","data","common1","common2","info1","info2","extract1","extract","extract2","COMMON_SECOND","COMMON_FIRST","data1","data2","extractAndNormalize","calculateOverlapFromDiff","diffs","sumPos","Math","abs","COMMON_NO","COMMON_BOTH","options","setOptions","newOptions","toLowerCase","commonFactor","widthBottom","widthTop","setTrapezoid","setFromTo","setPeaks1","anArray","checkArray","extracts","array1Extract","array1ExtractInfo","array2Extract","array2ExtractInfo","setPeaks2","getExtract1","getExtract2","getExtractInfo1","getExtractInfo2","newWidthBottom","newWidthTop","widthSlope","newFrom","newTo","getOverlap","x1","y1","x2","y2","diff","maxValue","getOverlapTrapezoid","factor","small","big","targets","segment","intersection","NaN","calculateDiff","newFirst","concat","newSecond","pos1","previous2","trapezoid","overlap","points","getSimilarity","newPeaks1","newPeaks2","result","extractInfo1","extractInfo2","similarity","fastSimilarity","matrix","compareNumbers","a","b","values","Infinity","l","minMax","arithmeticMean","mean","geometricMean","mul","pow","logMean","lnsum","log","grandMean","means","samples","n","truncatedMean","percent","alreadySorted","slice","sort","k","floor","harmonicMean","RangeError","contraHarmonicMean","r1","r2","median","half","variance","unbiased","theMean","theVariance","standardDeviation","sqrt","standardError","quartiles","quart","q1","ceil","q2","q3","pooledStandardDeviation","pooledVariance","vari","mode","itemCount","itemArray","count","index","indexOf","maxIndex","covariance","vector1","vector2","mean1","mean2","cov","skewness","s2","s3","dev","m2","m3","g","kurtosis","s4","m4","v","entropy","eps","weightedMean","weights","weightedStandardDeviation","weightedVariance","z","w","center","inPlace","standardize","standardDev","cumulativeSum","l1","l2","dimension","N","rows","cols","Error","sum1","sum2","medians","modes","skew","kurt","standardDeviations","standardErrors","sqrtN","scatter","divisor","correlation","scores","zScores","cor","jj","row","resultRow","sourceRow","isNaN","ii","weightSum","arrayStat","weightedCovariance","s1","weightedScatter"],"mappings":"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","file":"peaks-similarity.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"peaksSimilarity\"] = factory();\n\telse\n\t\troot[\"peaksSimilarity\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"peaksSimilarity\"] = factory();\n\telse\n\t\troot[\"peaksSimilarity\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar COMMON_NO=0;\n\tvar COMMON_FIRST=1;\n\tvar COMMON_SECOND=2;\n\tvar COMMON_BOTH=3; // should be a binary operation !\n\t\n\tvar Stat = __webpack_require__(1).array;\n\t\n\t\n\tmodule.exports = function Comparator(options) {\n\t    \n\t    var widthTop, widthBottom, from, to;\n\t    var array1Extract, array2Extract, widthSlope, array1ExtractInfo, array2ExtractInfo;\n\t    var common, commonFactor;\n\t\n\t    setOptions(options);\n\t\n\t    var array1=[];\n\t    var array2=[];\n\t \n\t    /*\n\t     2 formats are allowed:\n\t     [[x1,x2,...],[y1,y2,...]] or [[x1,y1],[x2,y2], ...]\n\t    */\n\t\n\t    function setOptions(newOptions) {\n\t        options=newOptions || {};\n\t        if (typeof options.common === 'string') {\n\t            if (options.common.toLowerCase()==='first') {\n\t                common=COMMON_FIRST;\n\t            } else if (options.common.toLowerCase()==='second') {\n\t                common=COMMON_SECOND;\n\t            } else if (options.common.toLowerCase()==='both') {\n\t                common=COMMON_BOTH;\n\t            } else {\n\t                common=COMMON_NO;\n\t            }\n\t        } else {\n\t            if (options.common==true) {\n\t                common=COMMON_BOTH;\n\t            } else {\n\t                common=COMMON_NO;\n\t            }\n\t        }\n\t        commonFactor=options.commonFactor || commonFactor || 4;\n\t\n\t        if (options.widthBottom==undefined) {\n\t            options.widthBottom=widthBottom || 2;\n\t        }\n\t        if (options.widthTop==undefined) {\n\t            options.widthTop=widthTop || 1;\n\t        }\n\t        setTrapezoid(options.widthBottom, options.widthTop);\n\t        setFromTo(options.from || from, options.to || to);\n\t    }\n\t\n\t    function setPeaks1(anArray) {\n\t        array1=checkArray(anArray);\n\t\n\t        if (common) {\n\t            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to, common);\n\t            array1Extract=extracts.data1;\n\t            array1ExtractInfo=extracts.info1;\n\t            array2Extract=extracts.data2;\n\t            array2ExtractInfo=extracts.info2;\n\t        } else {\n\t            var extract=extractAndNormalize(array1, from, to);\n\t            array1Extract=extract.data;\n\t            array1ExtractInfo=extract.info;\n\t        }\n\t    }\n\t    function setPeaks2(anArray) {\n\t        array2=checkArray(anArray);\n\t        if (common) {\n\t            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to, common);\n\t            array1Extract=extracts.data1;\n\t            array1ExtractInfo=extracts.info1;\n\t            array2Extract=extracts.data2;\n\t            array2ExtractInfo=extracts.info2;\n\t        } else {\n\t            var extract = extractAndNormalize(array2, from, to);\n\t            array2Extract = extract.data;\n\t            array2ExtractInfo = extract.info;\n\t        }\n\t    }\n\t\n\t    function getExtract1() {\n\t        return array1Extract;\n\t    }\n\t\n\t    function getExtract2() {\n\t        return array2Extract;\n\t    }\n\t\n\t\n\t    function getExtractInfo1() {\n\t        return array1ExtractInfo;\n\t    }\n\t\n\t    function getExtractInfo2() {\n\t        return array2ExtractInfo;\n\t    }\n\t\n\t    function setTrapezoid(newWidthBottom, newWidthTop) {\n\t        widthTop=newWidthTop;\n\t        widthBottom=newWidthBottom;\n\t        widthSlope=(widthBottom-widthTop)/2;\n\t        if (widthBottom<widthTop) throw \"widthBottom has to be larger than widthTop\";\n\t    }\n\t\n\t    function setFromTo(newFrom, newTo) {\n\t        if (newFrom===from && newTo===to) return\n\t        from=newFrom;\n\t        to=newTo;\n\t        if (common) {\n\t            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to, common, commonFactor);\n\t            array1Extract=extracts.data1;\n\t            array1ExtractInfo=extracts.info1;\n\t            array2Extract=extracts.data2;\n\t            array2ExtractInfo=extracts.info2;\n\t        } else {\n\t            var extract=extractAndNormalize(array1, from, to);\n\t            array1Extract=extract.data;\n\t            array1ExtractInfo=extract.info;\n\t            var extract=extractAndNormalize(array2, from, to);\n\t            array2Extract=extract.data;\n\t            array2ExtractInfo=extract.info;\n\t        }\n\t    }\n\t\n\t\n\t    function getOverlap(x1, y1, x2, y2) {\n\t        if (y1===0 || y2===0) return 0;\n\t\n\t        // TAKE CARE !!! We multiply the diff by 2 !!!\n\t        var diff=Math.abs(x1-x2)*2;\n\t\n\t        if (diff>widthBottom) return 0;\n\t        if (diff<=widthTop) {\n\t            return Math.min(y1,y2);\n\t        }\n\t\n\t        var maxValue=Math.max(y1,y2)*(widthBottom-diff)/(widthBottom-widthTop);\n\t        return Math.min(y1, y2, maxValue);\n\t\n\t        return NaN;\n\t    }\n\t\n\t    // This is the old trapezoid similarity\n\t    function getOverlapTrapezoid(x1, y1, x2, y2) {\n\t\n\t        var factor=2/(widthTop+widthBottom); // correction for surface=1\n\t        if (y1===0 || y2===0) return 0;\n\t        if (x1===x2) { // they have the same position\n\t            return Math.min(y1,y2);\n\t        }\n\t\n\t        var diff=Math.abs(x1-x2);\n\t        if (diff>=widthBottom) return 0;\n\t        if (y1===y2) { // do they have the same height ???\n\t            // we need to find the common length\n\t            if (diff<=widthTop) {\n\t                return (((widthTop+widthBottom)/2-diff)*y1)*factor;\n\t            } else if (diff<=widthBottom) {\n\t                return (widthBottom-diff)*y1/2*(diff-widthTop)/(widthBottom-widthTop)*factor;\n\t            }\n\t            return 0;\n\t        } else { // the height are different and not the same position ...\n\t            // we need to consider only one segment to find its intersection\n\t\n\t            var small=Math.min(y1,y2);\n\t            var big=Math.max(y1,y2);\n\t\n\t            var targets=[\n\t                [[0,0],[widthSlope,small]],\n\t                [[widthSlope,small],[widthSlope+widthTop,small]],\n\t                [[widthTop+widthSlope,small],[widthBottom,0]]\n\t            ];\n\t            if ((x1>x2 && y1>y2) || (x1<x2 && y1<y2)) {\n\t                var segment=[[diff,0],[diff+widthSlope,big]];\n\t            } else {\n\t                var segment=[[diff+widthSlope,big],[diff,0]];\n\t            }\n\t\n\t\n\t\n\t            for (var i=0; i<3; i++) {\n\t                var intersection=getIntersection(targets[i],segment);\n\t                if (intersection) {\n\t                    switch (i) {\n\t                        case 0:\n\t                            return small-((diff*intersection.y/2))*factor;\n\t                        case 1: // to simplify ...\n\t                            //     console.log(\"           \",widthSlope,small,big,intersection.x)\n\t                            return ((widthSlope*small/(2*big))*small+\n\t                                (widthTop+widthSlope-intersection.x)*small+\n\t                                widthSlope*small/2)*factor;\n\t                        case 2:\n\t                            return ((widthBottom-diff)*intersection.y/2)*factor;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return NaN;\n\t    }\n\t\n\t\n\t\n\t    // this method calculates the total diff. The sum of positive value will yield to overlap\n\t    function calculateDiff() {\n\t        // we need to take 2 pointers\n\t        // and travel progressively between them ...\n\t        var newFirst=[\n\t            [].concat(array1Extract[0]),\n\t            [].concat(array1Extract[1])\n\t        ];\n\t        var newSecond=[\n\t            [].concat(array2Extract[0]),\n\t            [].concat(array2Extract[1])\n\t        ];\n\t        var array1Length=array1Extract[0] ? array1Extract[0].length : 0;\n\t        var array2Length=array2Extract[0] ? array2Extract[0].length : 0;\n\t\n\t        var pos1=0;\n\t        var pos2=0;\n\t        var previous2=0;\n\t        while (pos1<array1Length) {\n\t            var diff=newFirst[0][pos1]-array2Extract[0][pos2];\n\t            if (Math.abs(diff)<widthBottom) { // there is some overlap\n\t                if (options.trapezoid) {\n\t                    var overlap=getOverlapTrapezoid(newFirst[0][pos1], newFirst[1][pos1], newSecond[0][pos2], newSecond[1][pos2], widthTop, widthBottom);\n\t                } else {\n\t                    var overlap=getOverlap(newFirst[0][pos1], newFirst[1][pos1], newSecond[0][pos2], newSecond[1][pos2], widthTop, widthBottom);\n\t                }\n\t                newFirst[1][pos1]-=overlap;\n\t                newSecond[1][pos2]-=overlap;\n\t                if (pos2<(array2Length-1)) {\n\t                    pos2++;\n\t                } else {\n\t                    pos1++;\n\t                    pos2=previous2;\n\t                }\n\t            } else {\n\t                if (diff>0 && pos2<(array2Length-1)) {\n\t                    pos2++;\n\t                    previous2=pos2;\n\t                } else {\n\t                    pos1++;\n\t                    pos2=previous2;\n\t                }\n\t            }\n\t        }\n\t        return newSecond;\n\t    }\n\t\n\t\n\t    /*\n\t        This code requires the use of an array like  [[x1,y1],[x2,y2], ...]\n\t        If it is not the right format, we will just convert it\n\t        Otherwise we return the correct format\n\t     */\n\t    function checkArray(points) {\n\t        // if it is already a 2D array of points, we just return them\n\t        if (Array.isArray(points) && Array.isArray(points[0]) && points.length===2) return points;\n\t        var x=new Array(points.length);\n\t        var y=new Array(points.length);\n\t        for (var i=0; i<points.length; i++) {\n\t            x[i]=points[i][0];\n\t            y[i]=points[i][1];\n\t        }\n\t        return [x,y];\n\t    }\n\t\n\t    function getSimilarity(newPeaks1, newPeaks2) {\n\t        if (newPeaks1) setPeaks1(newPeaks1);\n\t        if (newPeaks2) setPeaks2(newPeaks2);\n\t        var result={};\n\t        result.diff=calculateDiff();\n\t        result.extract1=getExtract1();\n\t        result.extract2=getExtract2();\n\t        result.extractInfo1=getExtractInfo1();\n\t        result.extractInfo2=getExtractInfo2();\n\t        result.similarity=calculateOverlapFromDiff(result.diff);\n\t        return result;\n\t    }\n\t\n\t    /*\n\t        This works mainly when you have a array1 that is fixed\n\t        newPeaks2 have to be normalized ! (sum to 1)\n\t     */\n\t    function fastSimilarity(newPeaks2, from, to) {\n\t        array1Extract=extract(array1, from, to);\n\t        array2Extract=newPeaks2;\n\t        if (common&COMMON_SECOND) array1Extract= getCommonArray(array1Extract, array2Extract, widthBottom)\n\t        normalize(array1Extract);\n\t        var diff=calculateDiff();\n\t        return calculateOverlapFromDiff(diff);\n\t    }\n\t\n\t\n\t    this.setPeaks1 = setPeaks1;\n\t    this.setPeaks2 = setPeaks2;\n\t    this.getExtract1 = getExtract1;\n\t    this.getExtract2 = getExtract2;\n\t    this.getExtractInfo1 = getExtractInfo1;\n\t    this.getExtractInfo2 = getExtractInfo2;\n\t    this.setFromTo = setFromTo;\n\t    this.setOptions = setOptions;\n\t    this.setTrapezoid = setTrapezoid;\n\t    this.getSimilarity = getSimilarity;\n\t    this.getCommonArray = getCommonArray;\n\t\n\t    this.fastSimilarity = fastSimilarity;\n\t\n\t};\n\t\n\t\n\t// returns an new array based on array1 where there is a peak of array2 at a distance under width/2\n\tfunction getCommonArray(array1, array2, width) {\n\t    var newArray=[[],[]];\n\t    var pos2=0;\n\t    width/=2;\n\t    var j=0;\n\t    var array1Length=array1[0] ? array1[0].length : 0;\n\t    var array2Length=array2[0] ? array2[0].length : 0;\n\t\n\t    for (var i=0; i<array1Length; i++) {\n\t        while (pos2<array2Length && (array1[0][i]>(array2[0][pos2]+width))) {\n\t            pos2++;\n\t        }\n\t        if ((pos2<array2Length) && (array1[0][i]>array2[0][pos2]-width)) {\n\t            newArray[0][j]=array1[0][i];\n\t            newArray[1][j]=array1[1][i];\n\t            j++;\n\t        }\n\t    }\n\t    return newArray;\n\t}\n\t\n\t\n\t// Adapted from: http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/1968345#1968345\n\tfunction getIntersection(segment1, segment2) {\n\t    var p0_x=segment1[0][0];\n\t    var p0_y=segment1[0][1];\n\t    var p1_x=segment1[1][0];\n\t    var p1_y=segment1[1][1];\n\t    var p2_x=segment2[0][0];\n\t    var p2_y=segment2[0][1];\n\t    var p3_x=segment2[1][0];\n\t    var p3_y=segment2[1][1];\n\t\n\t    var s1_x, s1_y, s2_x, s2_y;\n\t    s1_x = p1_x - p0_x;\n\t    s1_y = p1_y - p0_y;\n\t    s2_x = p3_x - p2_x;\n\t    s2_y = p3_y - p2_y;\n\t    var s, t;\n\t    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);\n\t    t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);\n\t    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n\t        return {\n\t            x:p0_x + (t * s1_x),\n\t            y:p0_y + (t * s1_y)\n\t        }\n\t    }\n\t    return null; // No collision\n\t}\n\t\n\tfunction normalize(array) {\n\t    var min=Stat.min(array[1]);\n\t    var max=Stat.max(array[1]);\n\t    var sum=Stat.sum(array[1]);\n\t    var length=array[1] ? array[1].length : 0;\n\t    if (sum!=0) {\n\t        for (var i=0; i<length; i++) {\n\t            array[1][i]/=sum;\n\t        }\n\t    }\n\t    return {\n\t        sum: sum,\n\t        min: min,\n\t        max: max\n\t    };\n\t}\n\t\n\t// this method will systemtatically take care of both array\n\tfunction commonExtractAndNormalize(array1, array2, width, from, to, common) {\n\t    if (! (Array.isArray(array1)) || ! (Array.isArray(array2))) return {\n\t        info: undefined,\n\t        data: undefined\n\t    };\n\t    var extract1=extract(array1, from, to);\n\t    var extract2=extract(array2, from, to);\n\t    var common1, common2, info1, info2;\n\t    if (common & COMMON_SECOND) {\n\t        common1=getCommonArray(extract1, extract2, width);\n\t        info1=normalize(common1);\n\t    } else {\n\t        common1=extract1;\n\t        info1=normalize(common1);\n\t    }\n\t    if (common & COMMON_FIRST) {\n\t        common2=getCommonArray(extract2, extract1, width);\n\t        info2=normalize(common2);\n\t    } else {\n\t        common2=extract2;\n\t        info2=normalize(common2);\n\t    }\n\t\n\t    return {\n\t        info1: info1,\n\t        info2: info2,\n\t        data1: common1,\n\t        data2: common2\n\t    }\n\t}\n\t\n\tfunction extract(array, from, to) {\n\t    var newArray=[[],[]];\n\t    var j=0;\n\t    var length=array[0] ? array[0].length : 0;\n\t    for (var i=0; i<length; i++) {\n\t        if ( (! from || array[0][i]>=from)  && (! to || array[0][i]<=to)) {\n\t            newArray[0][j] = array[0][i];\n\t            newArray[1][j] = array[1][i];\n\t            j++\n\t        }\n\t    }\n\t    return newArray;\n\t}\n\t\n\tfunction extractAndNormalize(array, from, to) {\n\t    if (! (Array.isArray(array))) return {\n\t        info: undefined,\n\t        data: undefined\n\t    };\n\t    var newArray=extract(array, from, to);\n\t    var info=normalize(newArray);\n\t    return {\n\t        info: info,\n\t        data: newArray\n\t    };\n\t}\n\t\n\tfunction calculateOverlapFromDiff(diffs) {\n\t    var sumPos=0;\n\t    for (var i=0; i<diffs[1].length; i++) {\n\t        sumPos+=Math.abs(diffs[1][i]);\n\t    }\n\t    return 1-sumPos;\n\t}\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.array = __webpack_require__(2);\n\texports.matrix = __webpack_require__(3);\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction compareNumbers(a, b) {\n\t    return a - b;\n\t}\n\t\n\t/**\n\t * Computes the sum of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.sum = function sum(values) {\n\t    var sum = 0;\n\t    for (var i = 0; i < values.length; i++) {\n\t        sum += values[i];\n\t    }\n\t    return sum;\n\t};\n\t\n\t/**\n\t * Computes the maximum of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.max = function max(values) {\n\t    var max = -Infinity;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] > max) max = values[i];\n\t    }\n\t    return max;\n\t};\n\t\n\t/**\n\t * Computes the minimum of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.min = function min(values) {\n\t    var min = Infinity;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] < min) min = values[i];\n\t    }\n\t    return min;\n\t};\n\t\n\t/**\n\t * Computes the min and max of the given values\n\t * @param {Array} values\n\t * @returns {{min: number, max: number}}\n\t */\n\texports.minMax = function minMax(values) {\n\t    var min = Infinity;\n\t    var max = -Infinity;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] < min) min = values[i];\n\t        if (values[i] > max) max = values[i];\n\t    }\n\t    return {\n\t        min: min,\n\t        max: max\n\t    };\n\t};\n\t\n\t/**\n\t * Computes the arithmetic mean of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.arithmeticMean = function arithmeticMean(values) {\n\t    var sum = 0;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        sum += values[i];\n\t    }\n\t    return sum / l;\n\t};\n\t\n\t/**\n\t * {@link arithmeticMean}\n\t */\n\texports.mean = exports.arithmeticMean;\n\t\n\t/**\n\t * Computes the geometric mean of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.geometricMean = function geometricMean(values) {\n\t    var mul = 1;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        mul *= values[i];\n\t    }\n\t    return Math.pow(mul, 1 / l);\n\t};\n\t\n\t/**\n\t * Computes the mean of the log of the given values\n\t * If the return value is exponentiated, it gives the same result as the\n\t * geometric mean.\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.logMean = function logMean(values) {\n\t    var lnsum = 0;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        lnsum += Math.log(values[i]);\n\t    }\n\t    return lnsum / l;\n\t};\n\t\n\t/**\n\t * Computes the weighted grand mean for a list of means and sample sizes\n\t * @param {Array} means - Mean values for each set of samples\n\t * @param {Array} samples - Number of original values for each set of samples\n\t * @returns {number}\n\t */\n\texports.grandMean = function grandMean(means, samples) {\n\t    var sum = 0;\n\t    var n = 0;\n\t    var l = means.length;\n\t    for (var i = 0; i < l; i++) {\n\t        sum += samples[i] * means[i];\n\t        n += samples[i];\n\t    }\n\t    return sum / n;\n\t};\n\t\n\t/**\n\t * Computes the truncated mean of the given values using a given percentage\n\t * @param {Array} values\n\t * @param {number} percent - The percentage of values to keep (range: [0,1])\n\t * @param {boolean} [alreadySorted=false]\n\t * @returns {number}\n\t */\n\texports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n\t    if (alreadySorted === undefined) alreadySorted = false;\n\t    if (!alreadySorted) {\n\t        values = values.slice().sort(compareNumbers);\n\t    }\n\t    var l = values.length;\n\t    var k = Math.floor(l * percent);\n\t    var sum = 0;\n\t    for (var i = k; i < (l - k); i++) {\n\t        sum += values[i];\n\t    }\n\t    return sum / (l - 2 * k);\n\t};\n\t\n\t/**\n\t * Computes the harmonic mean of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.harmonicMean = function harmonicMean(values) {\n\t    var sum = 0;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        if (values[i] === 0) {\n\t            throw new RangeError('value at index ' + i + 'is zero');\n\t        }\n\t        sum += 1 / values[i];\n\t    }\n\t    return l / sum;\n\t};\n\t\n\t/**\n\t * Computes the contraharmonic mean of the given values\n\t * @param {Array} values\n\t * @returns {number}\n\t */\n\texports.contraHarmonicMean = function contraHarmonicMean(values) {\n\t    var r1 = 0;\n\t    var r2 = 0;\n\t    var l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        r1 += values[i] * values[i];\n\t        r2 += values[i];\n\t    }\n\t    if (r2 < 0) {\n\t        throw new RangeError('sum of values is negative');\n\t    }\n\t    return r1 / r2;\n\t};\n\t\n\t/**\n\t * Computes the median of the given values\n\t * @param {Array} values\n\t * @param {boolean} [alreadySorted=false]\n\t * @returns {number}\n\t */\n\texports.median = function median(values, alreadySorted) {\n\t    if (alreadySorted === undefined) alreadySorted = false;\n\t    if (!alreadySorted) {\n\t        values = values.slice().sort(compareNumbers);\n\t    }\n\t    var l = values.length;\n\t    var half = Math.floor(l / 2);\n\t    if (l % 2 === 0) {\n\t        return (values[half - 1] + values[half]) * 0.5;\n\t    } else {\n\t        return values[half];\n\t    }\n\t};\n\t\n\t/**\n\t * Computes the variance of the given values\n\t * @param {Array} values\n\t * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n\t * @returns {number}\n\t */\n\texports.variance = function variance(values, unbiased) {\n\t    if (unbiased === undefined) unbiased = true;\n\t    var theMean = exports.mean(values);\n\t    var theVariance = 0;\n\t    var l = values.length;\n\t\n\t    for (var i = 0; i < l; i++) {\n\t        var x = values[i] - theMean;\n\t        theVariance += x * x;\n\t    }\n\t\n\t    if (unbiased) {\n\t        return theVariance / (l - 1);\n\t    } else {\n\t        return theVariance / l;\n\t    }\n\t};\n\t\n\t/**\n\t * Computes the standard deviation of the given values\n\t * @param {Array} values\n\t * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n\t * @returns {number}\n\t */\n\texports.standardDeviation = function standardDeviation(values, unbiased) {\n\t    return Math.sqrt(exports.variance(values, unbiased));\n\t};\n\t\n\texports.standardError = function standardError(values) {\n\t    return exports.standardDeviation(values) / Math.sqrt(values.length);\n\t};\n\t\n\texports.quartiles = function quartiles(values, alreadySorted) {\n\t    if (typeof(alreadySorted) === 'undefined') alreadySorted = false;\n\t    if (!alreadySorted) {\n\t        values = values.slice();\n\t        values.sort(compareNumbers);\n\t    }\n\t\n\t    var quart = values.length / 4;\n\t    var q1 = values[Math.ceil(quart) - 1];\n\t    var q2 = exports.median(values, true);\n\t    var q3 = values[Math.ceil(quart * 3) - 1];\n\t\n\t    return {q1: q1, q2: q2, q3: q3};\n\t};\n\t\n\texports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n\t    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n\t};\n\t\n\texports.pooledVariance = function pooledVariance(samples, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var sum = 0;\n\t    var length = 0, l = samples.length;\n\t    for (var i = 0; i < l; i++) {\n\t        var values = samples[i];\n\t        var vari = exports.variance(values);\n\t\n\t        sum += (values.length - 1) * vari;\n\t\n\t        if (unbiased)\n\t            length += values.length - 1;\n\t        else\n\t            length += values.length;\n\t    }\n\t    return sum / length;\n\t};\n\t\n\texports.mode = function mode(values) {\n\t    var l = values.length,\n\t        itemCount = new Array(l),\n\t        i;\n\t    for (i = 0; i < l; i++) {\n\t        itemCount[i] = 0;\n\t    }\n\t    var itemArray = new Array(l);\n\t    var count = 0;\n\t\n\t    for (i = 0; i < l; i++) {\n\t        var index = itemArray.indexOf(values[i]);\n\t        if (index >= 0)\n\t            itemCount[index]++;\n\t        else {\n\t            itemArray[count] = values[i];\n\t            itemCount[count] = 1;\n\t            count++;\n\t        }\n\t    }\n\t\n\t    var maxValue = 0, maxIndex = 0;\n\t    for (i = 0; i < count; i++) {\n\t        if (itemCount[i] > maxValue) {\n\t            maxValue = itemCount[i];\n\t            maxIndex = i;\n\t        }\n\t    }\n\t\n\t    return itemArray[maxIndex];\n\t};\n\t\n\texports.covariance = function covariance(vector1, vector2, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var mean1 = exports.mean(vector1);\n\t    var mean2 = exports.mean(vector2);\n\t\n\t    if (vector1.length !== vector2.length)\n\t        throw \"Vectors do not have the same dimensions\";\n\t\n\t    var cov = 0, l = vector1.length;\n\t    for (var i = 0; i < l; i++) {\n\t        var x = vector1[i] - mean1;\n\t        var y = vector2[i] - mean2;\n\t        cov += x * y;\n\t    }\n\t\n\t    if (unbiased)\n\t        return cov / (l - 1);\n\t    else\n\t        return cov / l;\n\t};\n\t\n\texports.skewness = function skewness(values, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var theMean = exports.mean(values);\n\t\n\t    var s2 = 0, s3 = 0, l = values.length;\n\t    for (var i = 0; i < l; i++) {\n\t        var dev = values[i] - theMean;\n\t        s2 += dev * dev;\n\t        s3 += dev * dev * dev;\n\t    }\n\t    var m2 = s2 / l;\n\t    var m3 = s3 / l;\n\t\n\t    var g = m3 / (Math.pow(m2, 3 / 2.0));\n\t    if (unbiased) {\n\t        var a = Math.sqrt(l * (l - 1));\n\t        var b = l - 2;\n\t        return (a / b) * g;\n\t    }\n\t    else {\n\t        return g;\n\t    }\n\t};\n\t\n\texports.kurtosis = function kurtosis(values, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var theMean = exports.mean(values);\n\t    var n = values.length, s2 = 0, s4 = 0;\n\t\n\t    for (var i = 0; i < n; i++) {\n\t        var dev = values[i] - theMean;\n\t        s2 += dev * dev;\n\t        s4 += dev * dev * dev * dev;\n\t    }\n\t    var m2 = s2 / n;\n\t    var m4 = s4 / n;\n\t\n\t    if (unbiased) {\n\t        var v = s2 / (n - 1);\n\t        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n\t        var b = s4 / (v * v);\n\t        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\t\n\t        return a * b - 3 * c;\n\t    }\n\t    else {\n\t        return m4 / (m2 * m2) - 3;\n\t    }\n\t};\n\t\n\texports.entropy = function entropy(values, eps) {\n\t    if (typeof(eps) === 'undefined') eps = 0;\n\t    var sum = 0, l = values.length;\n\t    for (var i = 0; i < l; i++)\n\t        sum += values[i] * Math.log(values[i] + eps);\n\t    return -sum;\n\t};\n\t\n\texports.weightedMean = function weightedMean(values, weights) {\n\t    var sum = 0, l = values.length;\n\t    for (var i = 0; i < l; i++)\n\t        sum += values[i] * weights[i];\n\t    return sum;\n\t};\n\t\n\texports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n\t    return Math.sqrt(exports.weightedVariance(values, weights));\n\t};\n\t\n\texports.weightedVariance = function weightedVariance(values, weights) {\n\t    var theMean = exports.weightedMean(values, weights);\n\t    var vari = 0, l = values.length;\n\t    var a = 0, b = 0;\n\t\n\t    for (var i = 0; i < l; i++) {\n\t        var z = values[i] - theMean;\n\t        var w = weights[i];\n\t\n\t        vari += w * (z * z);\n\t        b += w;\n\t        a += w * w;\n\t    }\n\t\n\t    return vari * (b / (b * b - a));\n\t};\n\t\n\texports.center = function center(values, inPlace) {\n\t    if (typeof(inPlace) === 'undefined') inPlace = false;\n\t\n\t    var result = values;\n\t    if (!inPlace)\n\t        result = values.slice();\n\t\n\t    var theMean = exports.mean(result), l = result.length;\n\t    for (var i = 0; i < l; i++)\n\t        result[i] -= theMean;\n\t};\n\t\n\texports.standardize = function standardize(values, standardDev, inPlace) {\n\t    if (typeof(standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n\t    if (typeof(inPlace) === 'undefined') inPlace = false;\n\t    var l = values.length;\n\t    var result = inPlace ? values : new Array(l);\n\t    for (var i = 0; i < l; i++)\n\t        result[i] = values[i] / standardDev;\n\t    return result;\n\t};\n\t\n\texports.cumulativeSum = function cumulativeSum(array) {\n\t    var l = array.length;\n\t    var result = new Array(l);\n\t    result[0] = array[0];\n\t    for (var i = 1; i < l; i++)\n\t        result[i] = result[i - 1] + array[i];\n\t    return result;\n\t};\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar arrayStat = __webpack_require__(2);\n\t\n\t// https://github.com/accord-net/framework/blob/development/Sources/Accord.Statistics/Tools.cs\n\t\n\tfunction entropy(matrix, eps) {\n\t    if (typeof(eps) === 'undefined') {\n\t        eps = 0;\n\t    }\n\t    var sum = 0,\n\t        l1 = matrix.length,\n\t        l2 = matrix[0].length;\n\t    for (var i = 0; i < l1; i++) {\n\t        for (var j = 0; j < l2; j++) {\n\t            sum += matrix[i][j] * Math.log(matrix[i][j] + eps);\n\t        }\n\t    }\n\t    return -sum;\n\t}\n\t\n\tfunction mean(matrix, dimension) {\n\t    if (typeof(dimension) === 'undefined') {\n\t        dimension = 0;\n\t    }\n\t    var rows = matrix.length,\n\t        cols = matrix[0].length,\n\t        theMean, N, i, j;\n\t\n\t    if (dimension === -1) {\n\t        theMean = [0];\n\t        N = rows * cols;\n\t        for (i = 0; i < rows; i++) {\n\t            for (j = 0; j < cols; j++) {\n\t                theMean[0] += matrix[i][j];\n\t            }\n\t        }\n\t        theMean[0] /= N;\n\t    } else if (dimension === 0) {\n\t        theMean = new Array(cols);\n\t        N = rows;\n\t        for (j = 0; j < cols; j++) {\n\t            theMean[j] = 0;\n\t            for (i = 0; i < rows; i++) {\n\t                theMean[j] += matrix[i][j];\n\t            }\n\t            theMean[j] /= N;\n\t        }\n\t    } else if (dimension === 1) {\n\t        theMean = new Array(rows);\n\t        N = cols;\n\t        for (j = 0; j < rows; j++) {\n\t            theMean[j] = 0;\n\t            for (i = 0; i < cols; i++) {\n\t                theMean[j] += matrix[j][i];\n\t            }\n\t            theMean[j] /= N;\n\t        }\n\t    } else {\n\t        throw new Error('Invalid dimension');\n\t    }\n\t    return theMean;\n\t}\n\t\n\tfunction standardDeviation(matrix, means, unbiased) {\n\t    var vari = variance(matrix, means, unbiased), l = vari.length;\n\t    for (var i = 0; i < l; i++) {\n\t        vari[i] = Math.sqrt(vari[i]);\n\t    }\n\t    return vari;\n\t}\n\t\n\tfunction variance(matrix, means, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') {\n\t        unbiased = true;\n\t    }\n\t    means = means || mean(matrix);\n\t    var rows = matrix.length;\n\t    if (rows === 0) return [];\n\t    var cols = matrix[0].length;\n\t    var vari = new Array(cols);\n\t\n\t    for (var j = 0; j < cols; j++) {\n\t        var sum1 = 0, sum2 = 0, x = 0;\n\t        for (var i = 0; i < rows; i++) {\n\t            x = matrix[i][j] - means[j];\n\t            sum1 += x;\n\t            sum2 += x * x;\n\t        }\n\t        if (unbiased) {\n\t            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / (rows - 1);\n\t        } else {\n\t            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / rows;\n\t        }\n\t    }\n\t    return vari;\n\t}\n\t\n\tfunction median(matrix) {\n\t    var rows = matrix.length, cols = matrix[0].length;\n\t    var medians = new Array(cols);\n\t\n\t    for (var i = 0; i < cols; i++) {\n\t        var data = new Array(rows);\n\t        for (var j = 0; j < rows; j++) {\n\t            data[j] = matrix[j][i];\n\t        }\n\t        data.sort();\n\t        var N = data.length;\n\t        if (N % 2 === 0) {\n\t            medians[i] = (data[N / 2] + data[(N / 2) - 1]) * 0.5;\n\t        } else {\n\t            medians[i] = data[Math.floor(N / 2)];\n\t        }\n\t    }\n\t    return medians;\n\t}\n\t\n\tfunction mode(matrix) {\n\t    var rows = matrix.length,\n\t        cols = matrix[0].length,\n\t        modes = new Array(cols),\n\t        i, j;\n\t    for (i = 0; i < cols; i++) {\n\t        var itemCount = new Array(rows);\n\t        for (var k = 0; k < rows; k++) {\n\t            itemCount[k] = 0;\n\t        }\n\t        var itemArray = new Array(rows);\n\t        var count = 0;\n\t\n\t        for (j = 0; j < rows; j++) {\n\t            var index = itemArray.indexOf(matrix[j][i]);\n\t            if (index >= 0) {\n\t                itemCount[index]++;\n\t            } else {\n\t                itemArray[count] = matrix[j][i];\n\t                itemCount[count] = 1;\n\t                count++;\n\t            }\n\t        }\n\t\n\t        var maxValue = 0, maxIndex = 0;\n\t        for (j = 0; j < count; j++) {\n\t            if (itemCount[j] > maxValue) {\n\t                maxValue = itemCount[j];\n\t                maxIndex = j;\n\t            }\n\t        }\n\t\n\t        modes[i] = itemArray[maxIndex];\n\t    }\n\t    return modes;\n\t}\n\t\n\tfunction skewness(matrix, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var means = mean(matrix);\n\t    var n = matrix.length, l = means.length;\n\t    var skew = new Array(l);\n\t\n\t    for (var j = 0; j < l; j++) {\n\t        var s2 = 0, s3 = 0;\n\t        for (var i = 0; i < n; i++) {\n\t            var dev = matrix[i][j] - means[j];\n\t            s2 += dev * dev;\n\t            s3 += dev * dev * dev;\n\t        }\n\t\n\t        var m2 = s2 / n;\n\t        var m3 = s3 / n;\n\t        var g = m3 / Math.pow(m2, 3 / 2);\n\t\n\t        if (unbiased) {\n\t            var a = Math.sqrt(n * (n - 1));\n\t            var b = n - 2;\n\t            skew[j] = (a / b) * g;\n\t        } else {\n\t            skew[j] = g;\n\t        }\n\t    }\n\t    return skew;\n\t}\n\t\n\tfunction kurtosis(matrix, unbiased) {\n\t    if (typeof(unbiased) === 'undefined') unbiased = true;\n\t    var means = mean(matrix);\n\t    var n = matrix.length, m = matrix[0].length;\n\t    var kurt = new Array(m);\n\t\n\t    for (var j = 0; j < m; j++) {\n\t        var s2 = 0, s4 = 0;\n\t        for (var i = 0; i < n; i++) {\n\t            var dev = matrix[i][j] - means[j];\n\t            s2 += dev * dev;\n\t            s4 += dev * dev * dev * dev;\n\t        }\n\t        var m2 = s2 / n;\n\t        var m4 = s4 / n;\n\t\n\t        if (unbiased) {\n\t            var v = s2 / (n - 1);\n\t            var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n\t            var b = s4 / (v * v);\n\t            var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\t            kurt[j] = a * b - 3 * c;\n\t        } else {\n\t            kurt[j] = m4 / (m2 * m2) - 3;\n\t        }\n\t    }\n\t    return kurt;\n\t}\n\t\n\tfunction standardError(matrix) {\n\t    var samples = matrix.length;\n\t    var standardDeviations = standardDeviation(matrix), l = standardDeviations.length;\n\t    var standardErrors = new Array(l);\n\t    var sqrtN = Math.sqrt(samples);\n\t\n\t    for (var i = 0; i < l; i++) {\n\t        standardErrors[i] = standardDeviations[i] / sqrtN;\n\t    }\n\t    return standardErrors;\n\t}\n\t\n\tfunction covariance(matrix, dimension) {\n\t    return scatter(matrix, undefined, dimension);\n\t}\n\t\n\tfunction scatter(matrix, divisor, dimension) {\n\t    if (typeof(dimension) === 'undefined') {\n\t        dimension = 0;\n\t    }\n\t    if (typeof(divisor) === 'undefined') {\n\t        if (dimension === 0) {\n\t            divisor = matrix.length - 1;\n\t        } else if (dimension === 1) {\n\t            divisor = matrix[0].length - 1;\n\t        }\n\t    }\n\t    var means = mean(matrix, dimension),\n\t        rows = matrix.length;\n\t    if (rows === 0) {\n\t        return [[]];\n\t    }\n\t    var cols = matrix[0].length,\n\t        cov, i, j, s, k;\n\t\n\t    if (dimension === 0) {\n\t        cov = new Array(cols);\n\t        for (i = 0; i < cols; i++) {\n\t            cov[i] = new Array(cols);\n\t        }\n\t        for (i = 0; i < cols; i++) {\n\t            for (j = i; j < cols; j++) {\n\t                s = 0;\n\t                for (k = 0; k < rows; k++) {\n\t                    s += (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n\t                }\n\t                s /= divisor;\n\t                cov[i][j] = s;\n\t                cov[j][i] = s;\n\t            }\n\t        }\n\t    } else if (dimension === 1) {\n\t        cov = new Array(rows);\n\t        for (i = 0; i < rows; i++) {\n\t            cov[i] = new Array(rows);\n\t        }\n\t        for (i = 0; i < rows; i++) {\n\t            for (j = i; j < rows; j++) {\n\t                s = 0;\n\t                for (k = 0; k < cols; k++) {\n\t                    s += (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n\t                }\n\t                s /= divisor;\n\t                cov[i][j] = s;\n\t                cov[j][i] = s;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Invalid dimension');\n\t    }\n\t\n\t    return cov;\n\t}\n\t\n\tfunction correlation(matrix) {\n\t    var means = mean(matrix),\n\t        standardDeviations = standardDeviation(matrix, true, means),\n\t        scores = zScores(matrix, means, standardDeviations),\n\t        rows = matrix.length,\n\t        cols = matrix[0].length,\n\t        i, j;\n\t\n\t    var cor = new Array(cols);\n\t    for (i = 0; i < cols; i++) {\n\t        cor[i] = new Array(cols);\n\t    }\n\t    for (i = 0; i < cols; i++) {\n\t        for (j = i; j < cols; j++) {\n\t            var c = 0;\n\t            for (var k = 0, l = scores.length; k < l; k++) {\n\t                c += scores[k][j] * scores[k][i];\n\t            }\n\t            c /= rows - 1;\n\t            cor[i][j] = c;\n\t            cor[j][i] = c;\n\t        }\n\t    }\n\t    return cor;\n\t}\n\t\n\tfunction zScores(matrix, means, standardDeviations) {\n\t    means = means || mean(matrix);\n\t    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix, true, means);\n\t    return standardize(center(matrix, means, false), standardDeviations, true);\n\t}\n\t\n\tfunction center(matrix, means, inPlace) {\n\t    means = means || mean(matrix);\n\t    var result = matrix,\n\t        l = matrix.length,\n\t        i, j, jj;\n\t\n\t    if (!inPlace) {\n\t        result = new Array(l);\n\t        for (i = 0; i < l; i++) {\n\t            result[i] = new Array(matrix[i].length);\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < l; i++) {\n\t        var row = result[i];\n\t        for (j = 0, jj = row.length; j < jj; j++) {\n\t            row[j] = matrix[i][j] - means[j];\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction standardize(matrix, standardDeviations, inPlace) {\n\t    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix);\n\t    var result = matrix,\n\t        l = matrix.length,\n\t        i, j, jj;\n\t\n\t    if (!inPlace) {\n\t        result = new Array(l);\n\t        for (i = 0; i < l; i++) {\n\t            result[i] = new Array(matrix[i].length);\n\t        }\n\t    }\n\t\n\t    for (i = 0; i < l; i++) {\n\t        var resultRow = result[i];\n\t        var sourceRow = matrix[i];\n\t        for (j = 0, jj = resultRow.length; j < jj; j++) {\n\t            if (standardDeviations[j] !== 0 && !isNaN(standardDeviations[j])) {\n\t                resultRow[j] = sourceRow[j] / standardDeviations[j];\n\t            }\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction weightedVariance(matrix, weights) {\n\t    var means = mean(matrix);\n\t    var rows = matrix.length;\n\t    if (rows === 0) return [];\n\t    var cols = matrix[0].length;\n\t    var vari = new Array(cols);\n\t\n\t    for (var j = 0; j < cols; j++) {\n\t        var sum = 0;\n\t        var a = 0, b = 0;\n\t\n\t        for (var i = 0; i < rows; i++) {\n\t            var z = matrix[i][j] - means[j];\n\t            var w = weights[i];\n\t\n\t            sum += w * (z * z);\n\t            b += w;\n\t            a += w * w;\n\t        }\n\t\n\t        vari[j] = sum * (b / (b * b - a));\n\t    }\n\t\n\t    return vari;\n\t}\n\t\n\tfunction weightedMean(matrix, weights, dimension) {\n\t    if (typeof(dimension) === 'undefined') {\n\t        dimension = 0;\n\t    }\n\t    var rows = matrix.length;\n\t    if (rows === 0) return [];\n\t    var cols = matrix[0].length,\n\t        means, i, ii, j, w, row;\n\t\n\t    if (dimension === 0) {\n\t        means = new Array(cols);\n\t        for (i = 0; i < cols; i++) {\n\t            means[i] = 0;\n\t        }\n\t        for (i = 0; i < rows; i++) {\n\t            row = matrix[i];\n\t            w = weights[i];\n\t            for (j = 0; j < cols; j++) {\n\t                means[j] += row[j] * w;\n\t            }\n\t        }\n\t    } else if (dimension === 1) {\n\t        means = new Array(rows);\n\t        for (i = 0; i < rows; i++) {\n\t            means[i] = 0;\n\t        }\n\t        for (j = 0; j < rows; j++) {\n\t            row = matrix[j];\n\t            w = weights[j];\n\t            for (i = 0; i < cols; i++) {\n\t                means[j] += row[i] * w;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Invalid dimension');\n\t    }\n\t\n\t    var weightSum = arrayStat.sum(weights);\n\t    if (weightSum !== 0) {\n\t        for (i = 0, ii = means.length; i < ii; i++) {\n\t            means[i] /= weightSum;\n\t        }\n\t    }\n\t    return means;\n\t}\n\t\n\tfunction weightedCovariance(matrix, weights, means, dimension) {\n\t    dimension = dimension || 0;\n\t    means = means || weightedMean(matrix, weights, dimension);\n\t    var s1 = 0, s2 = 0;\n\t    for (var i = 0, ii = weights.length; i < ii; i++) {\n\t        s1 += weights[i];\n\t        s2 += weights[i] * weights[i];\n\t    }\n\t    var factor = s1 / (s1 * s1 - s2);\n\t    return weightedScatter(matrix, weights, means, factor, dimension);\n\t}\n\t\n\tfunction weightedScatter(matrix, weights, means, factor, dimension) {\n\t    dimension = dimension || 0;\n\t    means = means || weightedMean(matrix, weights, dimension);\n\t    if (typeof(factor) === 'undefined') {\n\t        factor = 1;\n\t    }\n\t    var rows = matrix.length;\n\t    if (rows === 0) {\n\t        return [[]];\n\t    }\n\t    var cols = matrix[0].length,\n\t        cov, i, j, k, s;\n\t\n\t    if (dimension === 0) {\n\t        cov = new Array(cols);\n\t        for (i = 0; i < cols; i++) {\n\t            cov[i] = new Array(cols);\n\t        }\n\t        for (i = 0; i < cols; i++) {\n\t            for (j = i; j < cols; j++) {\n\t                s = 0;\n\t                for (k = 0; k < rows; k++) {\n\t                    s += weights[k] * (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n\t                }\n\t                cov[i][j] = s * factor;\n\t                cov[j][i] = s * factor;\n\t            }\n\t        }\n\t    } else if (dimension === 1) {\n\t        cov = new Array(rows);\n\t        for (i = 0; i < rows; i++) {\n\t            cov[i] = new Array(rows);\n\t        }\n\t        for (i = 0; i < rows; i++) {\n\t            for (j = i; j < rows; j++) {\n\t                s = 0;\n\t                for (k = 0; k < cols; k++) {\n\t                    s += weights[k] * (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n\t                }\n\t                cov[i][j] = s * factor;\n\t                cov[j][i] = s * factor;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Invalid dimension');\n\t    }\n\t\n\t    return cov;\n\t}\n\t\n\tmodule.exports = {\n\t    entropy: entropy,\n\t    mean: mean,\n\t    standardDeviation: standardDeviation,\n\t    variance: variance,\n\t    median: median,\n\t    mode: mode,\n\t    skewness: skewness,\n\t    kurtosis: kurtosis,\n\t    standardError: standardError,\n\t    covariance: covariance,\n\t    scatter: scatter,\n\t    correlation: correlation,\n\t    zScores: zScores,\n\t    center: center,\n\t    standardize: standardize,\n\t    weightedVariance: weightedVariance,\n\t    weightedMean: weightedMean,\n\t    weightedCovariance: weightedCovariance,\n\t    weightedScatter: weightedScatter\n\t};\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** peaks-similarity.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d1318b775e42c5b0c876\n **/","'use strict';\n\nvar COMMON_NO=0;\nvar COMMON_FIRST=1;\nvar COMMON_SECOND=2;\nvar COMMON_BOTH=3; // should be a binary operation !\n\nvar Stat = require('ml-stat').array;\n\n\nmodule.exports = function Comparator(options) {\n    \n    var widthTop, widthBottom, from, to;\n    var array1Extract, array2Extract, widthSlope, array1ExtractInfo, array2ExtractInfo;\n    var common, commonFactor;\n\n    setOptions(options);\n\n    var array1=[];\n    var array2=[];\n \n    /*\n     2 formats are allowed:\n     [[x1,x2,...],[y1,y2,...]] or [[x1,y1],[x2,y2], ...]\n    */\n\n    function setOptions(newOptions) {\n        options=newOptions || {};\n        if (typeof options.common === 'string') {\n            if (options.common.toLowerCase()==='first') {\n                common=COMMON_FIRST;\n            } else if (options.common.toLowerCase()==='second') {\n                common=COMMON_SECOND;\n            } else if (options.common.toLowerCase()==='both') {\n                common=COMMON_BOTH;\n            } else {\n                common=COMMON_NO;\n            }\n        } else {\n            if (options.common==true) {\n                common=COMMON_BOTH;\n            } else {\n                common=COMMON_NO;\n            }\n        }\n        commonFactor=options.commonFactor || commonFactor || 4;\n\n        if (options.widthBottom==undefined) {\n            options.widthBottom=widthBottom || 2;\n        }\n        if (options.widthTop==undefined) {\n            options.widthTop=widthTop || 1;\n        }\n        setTrapezoid(options.widthBottom, options.widthTop);\n        setFromTo(options.from || from, options.to || to);\n    }\n\n    function setPeaks1(anArray) {\n        array1=checkArray(anArray);\n\n        if (common) {\n            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to, common);\n            array1Extract=extracts.data1;\n            array1ExtractInfo=extracts.info1;\n            array2Extract=extracts.data2;\n            array2ExtractInfo=extracts.info2;\n        } else {\n            var extract=extractAndNormalize(array1, from, to);\n            array1Extract=extract.data;\n            array1ExtractInfo=extract.info;\n        }\n    }\n    function setPeaks2(anArray) {\n        array2=checkArray(anArray);\n        if (common) {\n            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to, common);\n            array1Extract=extracts.data1;\n            array1ExtractInfo=extracts.info1;\n            array2Extract=extracts.data2;\n            array2ExtractInfo=extracts.info2;\n        } else {\n            var extract = extractAndNormalize(array2, from, to);\n            array2Extract = extract.data;\n            array2ExtractInfo = extract.info;\n        }\n    }\n\n    function getExtract1() {\n        return array1Extract;\n    }\n\n    function getExtract2() {\n        return array2Extract;\n    }\n\n\n    function getExtractInfo1() {\n        return array1ExtractInfo;\n    }\n\n    function getExtractInfo2() {\n        return array2ExtractInfo;\n    }\n\n    function setTrapezoid(newWidthBottom, newWidthTop) {\n        widthTop=newWidthTop;\n        widthBottom=newWidthBottom;\n        widthSlope=(widthBottom-widthTop)/2;\n        if (widthBottom<widthTop) throw \"widthBottom has to be larger than widthTop\";\n    }\n\n    function setFromTo(newFrom, newTo) {\n        if (newFrom===from && newTo===to) return\n        from=newFrom;\n        to=newTo;\n        if (common) {\n            var extracts=commonExtractAndNormalize(array1, array2, widthBottom, from, to, common, commonFactor);\n            array1Extract=extracts.data1;\n            array1ExtractInfo=extracts.info1;\n            array2Extract=extracts.data2;\n            array2ExtractInfo=extracts.info2;\n        } else {\n            var extract=extractAndNormalize(array1, from, to);\n            array1Extract=extract.data;\n            array1ExtractInfo=extract.info;\n            var extract=extractAndNormalize(array2, from, to);\n            array2Extract=extract.data;\n            array2ExtractInfo=extract.info;\n        }\n    }\n\n\n    function getOverlap(x1, y1, x2, y2) {\n        if (y1===0 || y2===0) return 0;\n\n        // TAKE CARE !!! We multiply the diff by 2 !!!\n        var diff=Math.abs(x1-x2)*2;\n\n        if (diff>widthBottom) return 0;\n        if (diff<=widthTop) {\n            return Math.min(y1,y2);\n        }\n\n        var maxValue=Math.max(y1,y2)*(widthBottom-diff)/(widthBottom-widthTop);\n        return Math.min(y1, y2, maxValue);\n\n        return NaN;\n    }\n\n    // This is the old trapezoid similarity\n    function getOverlapTrapezoid(x1, y1, x2, y2) {\n\n        var factor=2/(widthTop+widthBottom); // correction for surface=1\n        if (y1===0 || y2===0) return 0;\n        if (x1===x2) { // they have the same position\n            return Math.min(y1,y2);\n        }\n\n        var diff=Math.abs(x1-x2);\n        if (diff>=widthBottom) return 0;\n        if (y1===y2) { // do they have the same height ???\n            // we need to find the common length\n            if (diff<=widthTop) {\n                return (((widthTop+widthBottom)/2-diff)*y1)*factor;\n            } else if (diff<=widthBottom) {\n                return (widthBottom-diff)*y1/2*(diff-widthTop)/(widthBottom-widthTop)*factor;\n            }\n            return 0;\n        } else { // the height are different and not the same position ...\n            // we need to consider only one segment to find its intersection\n\n            var small=Math.min(y1,y2);\n            var big=Math.max(y1,y2);\n\n            var targets=[\n                [[0,0],[widthSlope,small]],\n                [[widthSlope,small],[widthSlope+widthTop,small]],\n                [[widthTop+widthSlope,small],[widthBottom,0]]\n            ];\n            if ((x1>x2 && y1>y2) || (x1<x2 && y1<y2)) {\n                var segment=[[diff,0],[diff+widthSlope,big]];\n            } else {\n                var segment=[[diff+widthSlope,big],[diff,0]];\n            }\n\n\n\n            for (var i=0; i<3; i++) {\n                var intersection=getIntersection(targets[i],segment);\n                if (intersection) {\n                    switch (i) {\n                        case 0:\n                            return small-((diff*intersection.y/2))*factor;\n                        case 1: // to simplify ...\n                            //     console.log(\"           \",widthSlope,small,big,intersection.x)\n                            return ((widthSlope*small/(2*big))*small+\n                                (widthTop+widthSlope-intersection.x)*small+\n                                widthSlope*small/2)*factor;\n                        case 2:\n                            return ((widthBottom-diff)*intersection.y/2)*factor;\n                    }\n                }\n            }\n        }\n        return NaN;\n    }\n\n\n\n    // this method calculates the total diff. The sum of positive value will yield to overlap\n    function calculateDiff() {\n        // we need to take 2 pointers\n        // and travel progressively between them ...\n        var newFirst=[\n            [].concat(array1Extract[0]),\n            [].concat(array1Extract[1])\n        ];\n        var newSecond=[\n            [].concat(array2Extract[0]),\n            [].concat(array2Extract[1])\n        ];\n        var array1Length=array1Extract[0] ? array1Extract[0].length : 0;\n        var array2Length=array2Extract[0] ? array2Extract[0].length : 0;\n\n        var pos1=0;\n        var pos2=0;\n        var previous2=0;\n        while (pos1<array1Length) {\n            var diff=newFirst[0][pos1]-array2Extract[0][pos2];\n            if (Math.abs(diff)<widthBottom) { // there is some overlap\n                if (options.trapezoid) {\n                    var overlap=getOverlapTrapezoid(newFirst[0][pos1], newFirst[1][pos1], newSecond[0][pos2], newSecond[1][pos2], widthTop, widthBottom);\n                } else {\n                    var overlap=getOverlap(newFirst[0][pos1], newFirst[1][pos1], newSecond[0][pos2], newSecond[1][pos2], widthTop, widthBottom);\n                }\n                newFirst[1][pos1]-=overlap;\n                newSecond[1][pos2]-=overlap;\n                if (pos2<(array2Length-1)) {\n                    pos2++;\n                } else {\n                    pos1++;\n                    pos2=previous2;\n                }\n            } else {\n                if (diff>0 && pos2<(array2Length-1)) {\n                    pos2++;\n                    previous2=pos2;\n                } else {\n                    pos1++;\n                    pos2=previous2;\n                }\n            }\n        }\n        return newSecond;\n    }\n\n\n    /*\n        This code requires the use of an array like  [[x1,y1],[x2,y2], ...]\n        If it is not the right format, we will just convert it\n        Otherwise we return the correct format\n     */\n    function checkArray(points) {\n        // if it is already a 2D array of points, we just return them\n        if (Array.isArray(points) && Array.isArray(points[0]) && points.length===2) return points;\n        var x=new Array(points.length);\n        var y=new Array(points.length);\n        for (var i=0; i<points.length; i++) {\n            x[i]=points[i][0];\n            y[i]=points[i][1];\n        }\n        return [x,y];\n    }\n\n    function getSimilarity(newPeaks1, newPeaks2) {\n        if (newPeaks1) setPeaks1(newPeaks1);\n        if (newPeaks2) setPeaks2(newPeaks2);\n        var result={};\n        result.diff=calculateDiff();\n        result.extract1=getExtract1();\n        result.extract2=getExtract2();\n        result.extractInfo1=getExtractInfo1();\n        result.extractInfo2=getExtractInfo2();\n        result.similarity=calculateOverlapFromDiff(result.diff);\n        return result;\n    }\n\n    /*\n        This works mainly when you have a array1 that is fixed\n        newPeaks2 have to be normalized ! (sum to 1)\n     */\n    function fastSimilarity(newPeaks2, from, to) {\n        array1Extract=extract(array1, from, to);\n        array2Extract=newPeaks2;\n        if (common&COMMON_SECOND) array1Extract= getCommonArray(array1Extract, array2Extract, widthBottom)\n        normalize(array1Extract);\n        var diff=calculateDiff();\n        return calculateOverlapFromDiff(diff);\n    }\n\n\n    this.setPeaks1 = setPeaks1;\n    this.setPeaks2 = setPeaks2;\n    this.getExtract1 = getExtract1;\n    this.getExtract2 = getExtract2;\n    this.getExtractInfo1 = getExtractInfo1;\n    this.getExtractInfo2 = getExtractInfo2;\n    this.setFromTo = setFromTo;\n    this.setOptions = setOptions;\n    this.setTrapezoid = setTrapezoid;\n    this.getSimilarity = getSimilarity;\n    this.getCommonArray = getCommonArray;\n\n    this.fastSimilarity = fastSimilarity;\n\n};\n\n\n// returns an new array based on array1 where there is a peak of array2 at a distance under width/2\nfunction getCommonArray(array1, array2, width) {\n    var newArray=[[],[]];\n    var pos2=0;\n    width/=2;\n    var j=0;\n    var array1Length=array1[0] ? array1[0].length : 0;\n    var array2Length=array2[0] ? array2[0].length : 0;\n\n    for (var i=0; i<array1Length; i++) {\n        while (pos2<array2Length && (array1[0][i]>(array2[0][pos2]+width))) {\n            pos2++;\n        }\n        if ((pos2<array2Length) && (array1[0][i]>array2[0][pos2]-width)) {\n            newArray[0][j]=array1[0][i];\n            newArray[1][j]=array1[1][i];\n            j++;\n        }\n    }\n    return newArray;\n}\n\n\n// Adapted from: http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/1968345#1968345\nfunction getIntersection(segment1, segment2) {\n    var p0_x=segment1[0][0];\n    var p0_y=segment1[0][1];\n    var p1_x=segment1[1][0];\n    var p1_y=segment1[1][1];\n    var p2_x=segment2[0][0];\n    var p2_y=segment2[0][1];\n    var p3_x=segment2[1][0];\n    var p3_y=segment2[1][1];\n\n    var s1_x, s1_y, s2_x, s2_y;\n    s1_x = p1_x - p0_x;\n    s1_y = p1_y - p0_y;\n    s2_x = p3_x - p2_x;\n    s2_y = p3_y - p2_y;\n    var s, t;\n    s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);\n    t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n        return {\n            x:p0_x + (t * s1_x),\n            y:p0_y + (t * s1_y)\n        }\n    }\n    return null; // No collision\n}\n\nfunction normalize(array) {\n    var min=Stat.min(array[1]);\n    var max=Stat.max(array[1]);\n    var sum=Stat.sum(array[1]);\n    var length=array[1] ? array[1].length : 0;\n    if (sum!=0) {\n        for (var i=0; i<length; i++) {\n            array[1][i]/=sum;\n        }\n    }\n    return {\n        sum: sum,\n        min: min,\n        max: max\n    };\n}\n\n// this method will systemtatically take care of both array\nfunction commonExtractAndNormalize(array1, array2, width, from, to, common) {\n    if (! (Array.isArray(array1)) || ! (Array.isArray(array2))) return {\n        info: undefined,\n        data: undefined\n    };\n    var extract1=extract(array1, from, to);\n    var extract2=extract(array2, from, to);\n    var common1, common2, info1, info2;\n    if (common & COMMON_SECOND) {\n        common1=getCommonArray(extract1, extract2, width);\n        info1=normalize(common1);\n    } else {\n        common1=extract1;\n        info1=normalize(common1);\n    }\n    if (common & COMMON_FIRST) {\n        common2=getCommonArray(extract2, extract1, width);\n        info2=normalize(common2);\n    } else {\n        common2=extract2;\n        info2=normalize(common2);\n    }\n\n    return {\n        info1: info1,\n        info2: info2,\n        data1: common1,\n        data2: common2\n    }\n}\n\nfunction extract(array, from, to) {\n    var newArray=[[],[]];\n    var j=0;\n    var length=array[0] ? array[0].length : 0;\n    for (var i=0; i<length; i++) {\n        if ( (! from || array[0][i]>=from)  && (! to || array[0][i]<=to)) {\n            newArray[0][j] = array[0][i];\n            newArray[1][j] = array[1][i];\n            j++\n        }\n    }\n    return newArray;\n}\n\nfunction extractAndNormalize(array, from, to) {\n    if (! (Array.isArray(array))) return {\n        info: undefined,\n        data: undefined\n    };\n    var newArray=extract(array, from, to);\n    var info=normalize(newArray);\n    return {\n        info: info,\n        data: newArray\n    };\n}\n\nfunction calculateOverlapFromDiff(diffs) {\n    var sumPos=0;\n    for (var i=0; i<diffs[1].length; i++) {\n        sumPos+=Math.abs(diffs[1][i]);\n    }\n    return 1-sumPos;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\nexports.array = require('./array');\nexports.matrix = require('./matrix');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-stat/index.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\n/**\n * Computes the sum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.sum = function sum(values) {\n    var sum = 0;\n    for (var i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    return sum;\n};\n\n/**\n * Computes the maximum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.max = function max(values) {\n    var max = -Infinity;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] > max) max = values[i];\n    }\n    return max;\n};\n\n/**\n * Computes the minimum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.min = function min(values) {\n    var min = Infinity;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] < min) min = values[i];\n    }\n    return min;\n};\n\n/**\n * Computes the min and max of the given values\n * @param {Array} values\n * @returns {{min: number, max: number}}\n */\nexports.minMax = function minMax(values) {\n    var min = Infinity;\n    var max = -Infinity;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] < min) min = values[i];\n        if (values[i] > max) max = values[i];\n    }\n    return {\n        min: min,\n        max: max\n    };\n};\n\n/**\n * Computes the arithmetic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.arithmeticMean = function arithmeticMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        sum += values[i];\n    }\n    return sum / l;\n};\n\n/**\n * {@link arithmeticMean}\n */\nexports.mean = exports.arithmeticMean;\n\n/**\n * Computes the geometric mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.geometricMean = function geometricMean(values) {\n    var mul = 1;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        mul *= values[i];\n    }\n    return Math.pow(mul, 1 / l);\n};\n\n/**\n * Computes the mean of the log of the given values\n * If the return value is exponentiated, it gives the same result as the\n * geometric mean.\n * @param {Array} values\n * @returns {number}\n */\nexports.logMean = function logMean(values) {\n    var lnsum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        lnsum += Math.log(values[i]);\n    }\n    return lnsum / l;\n};\n\n/**\n * Computes the weighted grand mean for a list of means and sample sizes\n * @param {Array} means - Mean values for each set of samples\n * @param {Array} samples - Number of original values for each set of samples\n * @returns {number}\n */\nexports.grandMean = function grandMean(means, samples) {\n    var sum = 0;\n    var n = 0;\n    var l = means.length;\n    for (var i = 0; i < l; i++) {\n        sum += samples[i] * means[i];\n        n += samples[i];\n    }\n    return sum / n;\n};\n\n/**\n * Computes the truncated mean of the given values using a given percentage\n * @param {Array} values\n * @param {number} percent - The percentage of values to keep (range: [0,1])\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice().sort(compareNumbers);\n    }\n    var l = values.length;\n    var k = Math.floor(l * percent);\n    var sum = 0;\n    for (var i = k; i < (l - k); i++) {\n        sum += values[i];\n    }\n    return sum / (l - 2 * k);\n};\n\n/**\n * Computes the harmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.harmonicMean = function harmonicMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] === 0) {\n            throw new RangeError('value at index ' + i + 'is zero');\n        }\n        sum += 1 / values[i];\n    }\n    return l / sum;\n};\n\n/**\n * Computes the contraharmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.contraHarmonicMean = function contraHarmonicMean(values) {\n    var r1 = 0;\n    var r2 = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        r1 += values[i] * values[i];\n        r2 += values[i];\n    }\n    if (r2 < 0) {\n        throw new RangeError('sum of values is negative');\n    }\n    return r1 / r2;\n};\n\n/**\n * Computes the median of the given values\n * @param {Array} values\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.median = function median(values, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice().sort(compareNumbers);\n    }\n    var l = values.length;\n    var half = Math.floor(l / 2);\n    if (l % 2 === 0) {\n        return (values[half - 1] + values[half]) * 0.5;\n    } else {\n        return values[half];\n    }\n};\n\n/**\n * Computes the variance of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.variance = function variance(values, unbiased) {\n    if (unbiased === undefined) unbiased = true;\n    var theMean = exports.mean(values);\n    var theVariance = 0;\n    var l = values.length;\n\n    for (var i = 0; i < l; i++) {\n        var x = values[i] - theMean;\n        theVariance += x * x;\n    }\n\n    if (unbiased) {\n        return theVariance / (l - 1);\n    } else {\n        return theVariance / l;\n    }\n};\n\n/**\n * Computes the standard deviation of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.standardDeviation = function standardDeviation(values, unbiased) {\n    return Math.sqrt(exports.variance(values, unbiased));\n};\n\nexports.standardError = function standardError(values) {\n    return exports.standardDeviation(values) / Math.sqrt(values.length);\n};\n\nexports.quartiles = function quartiles(values, alreadySorted) {\n    if (typeof(alreadySorted) === 'undefined') alreadySorted = false;\n    if (!alreadySorted) {\n        values = values.slice();\n        values.sort(compareNumbers);\n    }\n\n    var quart = values.length / 4;\n    var q1 = values[Math.ceil(quart) - 1];\n    var q2 = exports.median(values, true);\n    var q3 = values[Math.ceil(quart * 3) - 1];\n\n    return {q1: q1, q2: q2, q3: q3};\n};\n\nexports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n};\n\nexports.pooledVariance = function pooledVariance(samples, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var sum = 0;\n    var length = 0, l = samples.length;\n    for (var i = 0; i < l; i++) {\n        var values = samples[i];\n        var vari = exports.variance(values);\n\n        sum += (values.length - 1) * vari;\n\n        if (unbiased)\n            length += values.length - 1;\n        else\n            length += values.length;\n    }\n    return sum / length;\n};\n\nexports.mode = function mode(values) {\n    var l = values.length,\n        itemCount = new Array(l),\n        i;\n    for (i = 0; i < l; i++) {\n        itemCount[i] = 0;\n    }\n    var itemArray = new Array(l);\n    var count = 0;\n\n    for (i = 0; i < l; i++) {\n        var index = itemArray.indexOf(values[i]);\n        if (index >= 0)\n            itemCount[index]++;\n        else {\n            itemArray[count] = values[i];\n            itemCount[count] = 1;\n            count++;\n        }\n    }\n\n    var maxValue = 0, maxIndex = 0;\n    for (i = 0; i < count; i++) {\n        if (itemCount[i] > maxValue) {\n            maxValue = itemCount[i];\n            maxIndex = i;\n        }\n    }\n\n    return itemArray[maxIndex];\n};\n\nexports.covariance = function covariance(vector1, vector2, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var mean1 = exports.mean(vector1);\n    var mean2 = exports.mean(vector2);\n\n    if (vector1.length !== vector2.length)\n        throw \"Vectors do not have the same dimensions\";\n\n    var cov = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        var x = vector1[i] - mean1;\n        var y = vector2[i] - mean2;\n        cov += x * y;\n    }\n\n    if (unbiased)\n        return cov / (l - 1);\n    else\n        return cov / l;\n};\n\nexports.skewness = function skewness(values, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n\n    var s2 = 0, s3 = 0, l = values.length;\n    for (var i = 0; i < l; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s3 += dev * dev * dev;\n    }\n    var m2 = s2 / l;\n    var m3 = s3 / l;\n\n    var g = m3 / (Math.pow(m2, 3 / 2.0));\n    if (unbiased) {\n        var a = Math.sqrt(l * (l - 1));\n        var b = l - 2;\n        return (a / b) * g;\n    }\n    else {\n        return g;\n    }\n};\n\nexports.kurtosis = function kurtosis(values, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n    var n = values.length, s2 = 0, s4 = 0;\n\n    for (var i = 0; i < n; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s4 += dev * dev * dev * dev;\n    }\n    var m2 = s2 / n;\n    var m4 = s4 / n;\n\n    if (unbiased) {\n        var v = s2 / (n - 1);\n        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n        var b = s4 / (v * v);\n        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\n        return a * b - 3 * c;\n    }\n    else {\n        return m4 / (m2 * m2) - 3;\n    }\n};\n\nexports.entropy = function entropy(values, eps) {\n    if (typeof(eps) === 'undefined') eps = 0;\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * Math.log(values[i] + eps);\n    return -sum;\n};\n\nexports.weightedMean = function weightedMean(values, weights) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * weights[i];\n    return sum;\n};\n\nexports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n    return Math.sqrt(exports.weightedVariance(values, weights));\n};\n\nexports.weightedVariance = function weightedVariance(values, weights) {\n    var theMean = exports.weightedMean(values, weights);\n    var vari = 0, l = values.length;\n    var a = 0, b = 0;\n\n    for (var i = 0; i < l; i++) {\n        var z = values[i] - theMean;\n        var w = weights[i];\n\n        vari += w * (z * z);\n        b += w;\n        a += w * w;\n    }\n\n    return vari * (b / (b * b - a));\n};\n\nexports.center = function center(values, inPlace) {\n    if (typeof(inPlace) === 'undefined') inPlace = false;\n\n    var result = values;\n    if (!inPlace)\n        result = values.slice();\n\n    var theMean = exports.mean(result), l = result.length;\n    for (var i = 0; i < l; i++)\n        result[i] -= theMean;\n};\n\nexports.standardize = function standardize(values, standardDev, inPlace) {\n    if (typeof(standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n    if (typeof(inPlace) === 'undefined') inPlace = false;\n    var l = values.length;\n    var result = inPlace ? values : new Array(l);\n    for (var i = 0; i < l; i++)\n        result[i] = values[i] / standardDev;\n    return result;\n};\n\nexports.cumulativeSum = function cumulativeSum(array) {\n    var l = array.length;\n    var result = new Array(l);\n    result[0] = array[0];\n    for (var i = 1; i < l; i++)\n        result[i] = result[i - 1] + array[i];\n    return result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-stat/array.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\nvar arrayStat = require('./array');\n\n// https://github.com/accord-net/framework/blob/development/Sources/Accord.Statistics/Tools.cs\n\nfunction entropy(matrix, eps) {\n    if (typeof(eps) === 'undefined') {\n        eps = 0;\n    }\n    var sum = 0,\n        l1 = matrix.length,\n        l2 = matrix[0].length;\n    for (var i = 0; i < l1; i++) {\n        for (var j = 0; j < l2; j++) {\n            sum += matrix[i][j] * Math.log(matrix[i][j] + eps);\n        }\n    }\n    return -sum;\n}\n\nfunction mean(matrix, dimension) {\n    if (typeof(dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        theMean, N, i, j;\n\n    if (dimension === -1) {\n        theMean = [0];\n        N = rows * cols;\n        for (i = 0; i < rows; i++) {\n            for (j = 0; j < cols; j++) {\n                theMean[0] += matrix[i][j];\n            }\n        }\n        theMean[0] /= N;\n    } else if (dimension === 0) {\n        theMean = new Array(cols);\n        N = rows;\n        for (j = 0; j < cols; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < rows; i++) {\n                theMean[j] += matrix[i][j];\n            }\n            theMean[j] /= N;\n        }\n    } else if (dimension === 1) {\n        theMean = new Array(rows);\n        N = cols;\n        for (j = 0; j < rows; j++) {\n            theMean[j] = 0;\n            for (i = 0; i < cols; i++) {\n                theMean[j] += matrix[j][i];\n            }\n            theMean[j] /= N;\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n    return theMean;\n}\n\nfunction standardDeviation(matrix, means, unbiased) {\n    var vari = variance(matrix, means, unbiased), l = vari.length;\n    for (var i = 0; i < l; i++) {\n        vari[i] = Math.sqrt(vari[i]);\n    }\n    return vari;\n}\n\nfunction variance(matrix, means, unbiased) {\n    if (typeof(unbiased) === 'undefined') {\n        unbiased = true;\n    }\n    means = means || mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum1 = 0, sum2 = 0, x = 0;\n        for (var i = 0; i < rows; i++) {\n            x = matrix[i][j] - means[j];\n            sum1 += x;\n            sum2 += x * x;\n        }\n        if (unbiased) {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / (rows - 1);\n        } else {\n            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / rows;\n        }\n    }\n    return vari;\n}\n\nfunction median(matrix) {\n    var rows = matrix.length, cols = matrix[0].length;\n    var medians = new Array(cols);\n\n    for (var i = 0; i < cols; i++) {\n        var data = new Array(rows);\n        for (var j = 0; j < rows; j++) {\n            data[j] = matrix[j][i];\n        }\n        data.sort();\n        var N = data.length;\n        if (N % 2 === 0) {\n            medians[i] = (data[N / 2] + data[(N / 2) - 1]) * 0.5;\n        } else {\n            medians[i] = data[Math.floor(N / 2)];\n        }\n    }\n    return medians;\n}\n\nfunction mode(matrix) {\n    var rows = matrix.length,\n        cols = matrix[0].length,\n        modes = new Array(cols),\n        i, j;\n    for (i = 0; i < cols; i++) {\n        var itemCount = new Array(rows);\n        for (var k = 0; k < rows; k++) {\n            itemCount[k] = 0;\n        }\n        var itemArray = new Array(rows);\n        var count = 0;\n\n        for (j = 0; j < rows; j++) {\n            var index = itemArray.indexOf(matrix[j][i]);\n            if (index >= 0) {\n                itemCount[index]++;\n            } else {\n                itemArray[count] = matrix[j][i];\n                itemCount[count] = 1;\n                count++;\n            }\n        }\n\n        var maxValue = 0, maxIndex = 0;\n        for (j = 0; j < count; j++) {\n            if (itemCount[j] > maxValue) {\n                maxValue = itemCount[j];\n                maxIndex = j;\n            }\n        }\n\n        modes[i] = itemArray[maxIndex];\n    }\n    return modes;\n}\n\nfunction skewness(matrix, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var means = mean(matrix);\n    var n = matrix.length, l = means.length;\n    var skew = new Array(l);\n\n    for (var j = 0; j < l; j++) {\n        var s2 = 0, s3 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s3 += dev * dev * dev;\n        }\n\n        var m2 = s2 / n;\n        var m3 = s3 / n;\n        var g = m3 / Math.pow(m2, 3 / 2);\n\n        if (unbiased) {\n            var a = Math.sqrt(n * (n - 1));\n            var b = n - 2;\n            skew[j] = (a / b) * g;\n        } else {\n            skew[j] = g;\n        }\n    }\n    return skew;\n}\n\nfunction kurtosis(matrix, unbiased) {\n    if (typeof(unbiased) === 'undefined') unbiased = true;\n    var means = mean(matrix);\n    var n = matrix.length, m = matrix[0].length;\n    var kurt = new Array(m);\n\n    for (var j = 0; j < m; j++) {\n        var s2 = 0, s4 = 0;\n        for (var i = 0; i < n; i++) {\n            var dev = matrix[i][j] - means[j];\n            s2 += dev * dev;\n            s4 += dev * dev * dev * dev;\n        }\n        var m2 = s2 / n;\n        var m4 = s4 / n;\n\n        if (unbiased) {\n            var v = s2 / (n - 1);\n            var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n            var b = s4 / (v * v);\n            var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n            kurt[j] = a * b - 3 * c;\n        } else {\n            kurt[j] = m4 / (m2 * m2) - 3;\n        }\n    }\n    return kurt;\n}\n\nfunction standardError(matrix) {\n    var samples = matrix.length;\n    var standardDeviations = standardDeviation(matrix), l = standardDeviations.length;\n    var standardErrors = new Array(l);\n    var sqrtN = Math.sqrt(samples);\n\n    for (var i = 0; i < l; i++) {\n        standardErrors[i] = standardDeviations[i] / sqrtN;\n    }\n    return standardErrors;\n}\n\nfunction covariance(matrix, dimension) {\n    return scatter(matrix, undefined, dimension);\n}\n\nfunction scatter(matrix, divisor, dimension) {\n    if (typeof(dimension) === 'undefined') {\n        dimension = 0;\n    }\n    if (typeof(divisor) === 'undefined') {\n        if (dimension === 0) {\n            divisor = matrix.length - 1;\n        } else if (dimension === 1) {\n            divisor = matrix[0].length - 1;\n        }\n    }\n    var means = mean(matrix, dimension),\n        rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, s, k;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                s /= divisor;\n                cov[i][j] = s;\n                cov[j][i] = s;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n}\n\nfunction correlation(matrix) {\n    var means = mean(matrix),\n        standardDeviations = standardDeviation(matrix, true, means),\n        scores = zScores(matrix, means, standardDeviations),\n        rows = matrix.length,\n        cols = matrix[0].length,\n        i, j;\n\n    var cor = new Array(cols);\n    for (i = 0; i < cols; i++) {\n        cor[i] = new Array(cols);\n    }\n    for (i = 0; i < cols; i++) {\n        for (j = i; j < cols; j++) {\n            var c = 0;\n            for (var k = 0, l = scores.length; k < l; k++) {\n                c += scores[k][j] * scores[k][i];\n            }\n            c /= rows - 1;\n            cor[i][j] = c;\n            cor[j][i] = c;\n        }\n    }\n    return cor;\n}\n\nfunction zScores(matrix, means, standardDeviations) {\n    means = means || mean(matrix);\n    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix, true, means);\n    return standardize(center(matrix, means, false), standardDeviations, true);\n}\n\nfunction center(matrix, means, inPlace) {\n    means = means || mean(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var row = result[i];\n        for (j = 0, jj = row.length; j < jj; j++) {\n            row[j] = matrix[i][j] - means[j];\n        }\n    }\n    return result;\n}\n\nfunction standardize(matrix, standardDeviations, inPlace) {\n    if (typeof(standardDeviations) === 'undefined') standardDeviations = standardDeviation(matrix);\n    var result = matrix,\n        l = matrix.length,\n        i, j, jj;\n\n    if (!inPlace) {\n        result = new Array(l);\n        for (i = 0; i < l; i++) {\n            result[i] = new Array(matrix[i].length);\n        }\n    }\n\n    for (i = 0; i < l; i++) {\n        var resultRow = result[i];\n        var sourceRow = matrix[i];\n        for (j = 0, jj = resultRow.length; j < jj; j++) {\n            if (standardDeviations[j] !== 0 && !isNaN(standardDeviations[j])) {\n                resultRow[j] = sourceRow[j] / standardDeviations[j];\n            }\n        }\n    }\n    return result;\n}\n\nfunction weightedVariance(matrix, weights) {\n    var means = mean(matrix);\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length;\n    var vari = new Array(cols);\n\n    for (var j = 0; j < cols; j++) {\n        var sum = 0;\n        var a = 0, b = 0;\n\n        for (var i = 0; i < rows; i++) {\n            var z = matrix[i][j] - means[j];\n            var w = weights[i];\n\n            sum += w * (z * z);\n            b += w;\n            a += w * w;\n        }\n\n        vari[j] = sum * (b / (b * b - a));\n    }\n\n    return vari;\n}\n\nfunction weightedMean(matrix, weights, dimension) {\n    if (typeof(dimension) === 'undefined') {\n        dimension = 0;\n    }\n    var rows = matrix.length;\n    if (rows === 0) return [];\n    var cols = matrix[0].length,\n        means, i, ii, j, w, row;\n\n    if (dimension === 0) {\n        means = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            means[i] = 0;\n        }\n        for (i = 0; i < rows; i++) {\n            row = matrix[i];\n            w = weights[i];\n            for (j = 0; j < cols; j++) {\n                means[j] += row[j] * w;\n            }\n        }\n    } else if (dimension === 1) {\n        means = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            means[i] = 0;\n        }\n        for (j = 0; j < rows; j++) {\n            row = matrix[j];\n            w = weights[j];\n            for (i = 0; i < cols; i++) {\n                means[j] += row[i] * w;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    var weightSum = arrayStat.sum(weights);\n    if (weightSum !== 0) {\n        for (i = 0, ii = means.length; i < ii; i++) {\n            means[i] /= weightSum;\n        }\n    }\n    return means;\n}\n\nfunction weightedCovariance(matrix, weights, means, dimension) {\n    dimension = dimension || 0;\n    means = means || weightedMean(matrix, weights, dimension);\n    var s1 = 0, s2 = 0;\n    for (var i = 0, ii = weights.length; i < ii; i++) {\n        s1 += weights[i];\n        s2 += weights[i] * weights[i];\n    }\n    var factor = s1 / (s1 * s1 - s2);\n    return weightedScatter(matrix, weights, means, factor, dimension);\n}\n\nfunction weightedScatter(matrix, weights, means, factor, dimension) {\n    dimension = dimension || 0;\n    means = means || weightedMean(matrix, weights, dimension);\n    if (typeof(factor) === 'undefined') {\n        factor = 1;\n    }\n    var rows = matrix.length;\n    if (rows === 0) {\n        return [[]];\n    }\n    var cols = matrix[0].length,\n        cov, i, j, k, s;\n\n    if (dimension === 0) {\n        cov = new Array(cols);\n        for (i = 0; i < cols; i++) {\n            cov[i] = new Array(cols);\n        }\n        for (i = 0; i < cols; i++) {\n            for (j = i; j < cols; j++) {\n                s = 0;\n                for (k = 0; k < rows; k++) {\n                    s += weights[k] * (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else if (dimension === 1) {\n        cov = new Array(rows);\n        for (i = 0; i < rows; i++) {\n            cov[i] = new Array(rows);\n        }\n        for (i = 0; i < rows; i++) {\n            for (j = i; j < rows; j++) {\n                s = 0;\n                for (k = 0; k < cols; k++) {\n                    s += weights[k] * (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);\n                }\n                cov[i][j] = s * factor;\n                cov[j][i] = s * factor;\n            }\n        }\n    } else {\n        throw new Error('Invalid dimension');\n    }\n\n    return cov;\n}\n\nmodule.exports = {\n    entropy: entropy,\n    mean: mean,\n    standardDeviation: standardDeviation,\n    variance: variance,\n    median: median,\n    mode: mode,\n    skewness: skewness,\n    kurtosis: kurtosis,\n    standardError: standardError,\n    covariance: covariance,\n    scatter: scatter,\n    correlation: correlation,\n    zScores: zScores,\n    center: center,\n    standardize: standardize,\n    weightedVariance: weightedVariance,\n    weightedMean: weightedMean,\n    weightedCovariance: weightedCovariance,\n    weightedScatter: weightedScatter\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ml-stat/matrix.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}