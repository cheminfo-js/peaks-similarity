{"version":3,"sources":["peaks-similarity.min.js"],"names":["e","exports","module","define","amd","f","window","global","self","peaksSimilarity","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"options","setOptions","newOptions","setTrapezoid","widthBottom","widthTop","setFromTo","from","to","setPeaks1","anArray","array1","checkArray","array1Extract","extractAndNormalize","setPeaks2","array2","array2Extract","getExtract1","getExtract2","newWidthBottom","newWidthTop","widthSlope","newFrom","newTo","getOverlap","x1","y1","x2","y2","factor","Math","min","diff","abs","small","big","max","targets","segment","intersection","getIntersection","y","x","NaN","segment1","segment2","s1_x","s1_y","s2_x","s2_y","p0_x","p0_y","p1_x","p1_y","p2_x","p2_y","p3_x","p3_y","calculateDiff","newSecond","push","newFirst","pos1","pos2","previous2","overlap","calculateOverlapFromDiff","diffs","sumPos","normalize","array","sum","Array","newArray","j","points","constructor","xs","ys","getSimilarity","newPeaks1","newPeaks2","result","extract1","extract2","similarity","this"],"mappings":"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","file":"peaks-similarity.min.js","sourcesContent":["/**\n * peaks-similarity - Peaks similarity - calculate the similarity between 2 ordered array of peaks\n * @version v1.0.0\n * @link https://github.com/cheminfo-js/peaks-similarity\n * @license MIT\n */\n!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.peaksSimilarity=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nmodule.exports = function Comparator(options) {\n    \n    var widthTop, widthBottom, from, to, array1Extract, array2Extract, widthSlope;\n\n\n    setOptions(options);\n\n    var array1=[];\n    var array2=[];\n \n    /*\n     2 formats are allowed:\n     [[x1,x2,...],[y1,y2,...]] or [[x1,y1],[x2,y2], ...]\n    */\n\n    function setOptions(newOptions) {\n        options=newOptions || {};\n        setTrapezoid(\n            options.widthBottom || widthBottom || 2,\n            options.widthTop || widthTop || 1\n        );\n        setFromTo(options.from || from, options.to || to);\n    }\n\n    function setPeaks1(anArray) {\n        array1=checkArray(anArray);\n        array1Extract=extractAndNormalize(array1, from, to);\n    }\n    function setPeaks2(anArray) {\n        array2=checkArray(anArray);\n        array2Extract=extractAndNormalize(array2, from, to);\n    }\n\n    function getExtract1() {\n        return array1Extract;\n    }\n\n    function getExtract2() {\n        return array2Extract;\n    }\n\n    function setTrapezoid(newWidthBottom, newWidthTop) {\n        widthTop=newWidthTop;\n        widthBottom=newWidthBottom;\n        widthSlope=(widthBottom-widthTop)/2;\n        if (widthBottom<widthTop) throw \"widthBottom has to be larger than widthTop\";\n    }\n\n    function setFromTo(newFrom, newTo) {\n        from=newFrom;\n        to=newTo;\n        array1Extract=extractAndNormalize(array1, from, to);\n        array2Extract=extractAndNormalize(array2, from, to);\n    }\n\n    function getOverlap(x1, y1, x2, y2) {\n\n        var factor=2/(widthTop+widthBottom); // correction for surface=1\n        if (y1===0 || y2===0) return 0;\n        if (x1===x2) { // they have the same position\n            return Math.min(y1,y2);\n        }\n\n        var diff=Math.abs(x1-x2);\n        if (diff>=widthBottom) return 0;\n        if (y1===y2) { // do they have the same height ???\n            // we need to find the common length\n            if (diff<=widthTop) {\n                return (((widthTop+widthBottom)/2-diff)*y1)*factor;\n            } else if (diff<=widthBottom) {\n                return (widthBottom-diff)*y1/2*(diff-widthTop)/(widthBottom-widthTop)*factor;\n            }\n            return 0;\n        } else { // the height are different and not the same position ...\n            // we need to consider only one segment to find its intersection\n\n            var small=Math.min(y1,y2);\n            var big=Math.max(y1,y2);\n\n            var targets=[\n                [[0,0],[widthSlope,small]],\n                [[widthSlope,small],[widthSlope+widthTop,small]],\n                [[widthTop+widthSlope,small],[widthBottom,0]]\n            ];\n            if ((x1>x2 && y1>y2) || (x1<x2 && y1<y2)) {\n                var segment=[[diff,0],[diff+widthSlope,big]];\n            } else {\n                var segment=[[diff+widthSlope,big],[diff,0]];\n            }\n\n\n\n            for (var i=0; i<3; i++) {\n                var intersection=getIntersection(targets[i],segment);\n                if (intersection) {\n                    switch (i) {\n                        case 0:\n                            return small-((diff*intersection.y/2))*factor;\n                        case 1: // to simplify ...\n                            //     console.log(\"           \",widthSlope,small,big,intersection.x)\n                            return ((widthSlope*small/(2*big))*small+\n                                (widthTop+widthSlope-intersection.x)*small+\n                                widthSlope*small/2)*factor;\n                        case 2:\n                            return ((widthBottom-diff)*intersection.y/2)*factor;\n                    }\n                }\n            }\n        }\n        return NaN;\n    }\n\n// Adapted from: http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/1968345#1968345\n    function getIntersection(segment1, segment2) {\n        var p0_x=segment1[0][0];\n        var p0_y=segment1[0][1];\n        var p1_x=segment1[1][0];\n        var p1_y=segment1[1][1];\n        var p2_x=segment2[0][0];\n        var p2_y=segment2[0][1];\n        var p3_x=segment2[1][0];\n        var p3_y=segment2[1][1];\n\n        var s1_x, s1_y, s2_x, s2_y;\n        s1_x = p1_x - p0_x;\n        s1_y = p1_y - p0_y;\n        s2_x = p3_x - p2_x;\n        s2_y = p3_y - p2_y;\n        var s, t;\n        s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);\n        t = ( s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);\n        if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n            return {\n                x:p0_x + (t * s1_x),\n                y:p0_y + (t * s1_y)\n            }\n        }\n        return null; // No collision\n    }\n\n    // this method calculates the total diff. The sum of positive value will yield to overlap\n    function calculateDiff() {\n        // we need to take 2 pointers\n        // and travel progressively between them ...\n        var newSecond=[];\n        for (var i=0; i<array2Extract.length; i++) {\n            newSecond.push([array2Extract[i][0],array2Extract[i][1]]);\n        }\n        var newFirst=[];\n        for (var i=0; i<array1Extract.length; i++) {\n            newFirst.push([array1Extract[i][0],array1Extract[i][1]]);\n        }\n\n        var pos1=0;\n        var pos2=0;\n        var previous2=0;\n        while (pos1<newFirst.length) {\n            var diff=newFirst[pos1][0]-array2Extract[pos2][0];\n            if (Math.abs(diff)<widthBottom) { // there is some overlap\n                var overlap=getOverlap(newFirst[pos1][0], newFirst[pos1][1], newSecond[pos2][0], newSecond[pos2][1], widthTop, widthBottom);\n                newFirst[pos1][1]-=overlap;\n                newSecond[pos2][1]-=overlap;\n                if (pos2<(array2Extract.length-1)) {\n                    pos2++;\n                } else {\n                    pos1++;\n                    pos2=previous2;\n                }\n            } else {\n                if (diff>0 && pos2<(array2Extract.length-1)) {\n                    pos2++;\n                    previous2=pos2;\n                } else {\n                    pos1++;\n                    pos2=previous2;\n                }\n            }\n        }\n        return newSecond;\n    }\n\n    function calculateOverlapFromDiff(diffs) {\n        var sumPos=0;\n        for (var i=0; i<diffs.length; i++) {\n            sumPos+=Math.abs(diffs[i][1]);\n        }\n        return 1-sumPos;\n    }\n\n    function normalize(array) {\n        var sum=0;\n        for (var i=0; i<array.length; i++) {\n            sum+=array[i][1];\n        }\n        for (var i=0; i<array.length; i++) {\n            array[i][1]/=sum;\n        }\n    }\n\n    function extractAndNormalize(array, from, to) {\n        if (! (array instanceof Array)) return;\n        var newArray=[];\n        var j=0;\n        for (var i=0; i<array.length; i++) {\n            if ( (! from || array[i][0]>=from)  && (! to || array[i][0]<=to)) {\n                newArray[j++]=[array[i][0],array[i][1]];\n            }\n        }\n        normalize(newArray);\n        return newArray;\n    }\n\n    /*\n        This code requires the use of an array like  [[x1,y1],[x2,y2], ...]\n        If it is not the right format, we will just convert it\n        Otherwise we return the correct format\n     */\n    function checkArray(points) {\n        // if it is already a 2D array of points, we just return them\n        if (points.constructor === Array && points[0].constructor === Array && points[0].length===2) return points;\n        var xs=points[0];\n        var ys=points[1];\n        var array=[];\n        for (var i=0; i<xs.length; i++) {\n            array.push([xs[i],ys[i]]);\n        }\n        return array;\n    }\n\n    function getSimilarity(newPeaks1, newPeaks2) {\n        if (newPeaks1) setPeaks1(newPeaks1);\n        if (newPeaks2) setPeaks2(newPeaks2);\n        var result={};\n        result.diff=calculateDiff();\n        result.extract1=getExtract1();\n        result.extract2=getExtract2();\n        result.similarity=calculateOverlapFromDiff(result.diff);\n        return result;\n    }\n\n    this.setPeaks1 = setPeaks1;\n    this.setPeaks2 = setPeaks2;\n    this.getExtract1 = getExtract1;\n    this.getExtract2 = getExtract2;\n    this.setFromTo = setFromTo;\n    this.setOptions = setOptions;\n    this.setTrapezoid = setTrapezoid;\n    this.getSimilarity = getSimilarity;\n};\n\n},{}]},{},[1])(1)\n});"],"sourceRoot":"/source/"}